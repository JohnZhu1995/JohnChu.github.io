{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Bitwise-operation-on-integers-basics-of-C.md","hash":"5d89082c800f074816d98cb04cf99193f40cb962","modified":1648196890825},{"_id":"source/_posts/first-post-from-john.md","hash":"db1e44597c81184478baec2fe7ac762b847ca305","modified":1646719154787},{"_id":"source/_posts/electron02-调用DLL.md","hash":"32a1719919b2f1b5c5efa95c7f6d7e1ca2f444fe","modified":1648197161367},{"_id":"source/_posts/部署项目到服务器操作流程.md","hash":"5b63445c5184cabbc437e88ad0846968f6d849d4","modified":1647930073501},{"_id":"source/_posts/An-introduction-to-HTML-CSS-JS/DOM.png","hash":"9c482d4610ec60c994138419d264dc8f1b2544d5","modified":1648799874644},{"_id":"source/_posts/electron02-调用DLL/01.png","hash":"2b455e675b5447586456e7bb68cd685fb0e3010c","modified":1646721129823},{"_id":"source/_posts/electron02-调用DLL/02.png","hash":"b1b1af829ff5735319fe83c8b37c73c18e8f2647","modified":1646728681860},{"_id":"source/_posts/electron02-调用DLL/03.png","hash":"c90ecfdd8a6cc080ed5b01992fd6a6893c8715d2","modified":1646729488303},{"_id":"source/_posts/electron02-调用DLL/04.png","hash":"e1ca6d20ae488b3d1272cd8e71eb836ce0bb4ca9","modified":1646729906796},{"_id":"source/_posts/electron02-调用DLL/05.png","hash":"b005c9e24f5b4a2c46e09214830c0120d5b224e0","modified":1646731211932},{"_id":"source/_posts/部署项目到服务器操作流程/02.png","hash":"97bc243d215f9c7e1e9eaf12ae2ff566430c8613","modified":1647930064127},{"_id":"source/_posts/An-introduction-to-HTML-CSS-JS/metaphor.png","hash":"e6f5e4409907429f61a3f06efb10b66f88b487b2","modified":1648783257372},{"_id":"source/_posts/部署项目到服务器操作流程/01.png","hash":"7b53927615215071037a8b56877be6ada21d5de2","modified":1647928704026},{"_id":"source/_posts/An-introduction-to-HTML-CSS-JS/render.png","hash":"787cb81024b7980562274a9b4d5b0ccc73bfcc91","modified":1648800567337},{"_id":"source/_posts/An-introduction-to-HTML-CSS-JS.md","hash":"505daca460956d7b52e118478d31cc7623656d7c","modified":1648804341473},{"_id":"themes/landscape/.npmignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1646719154787},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1646719154787},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1646719154787},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1646719154788},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1646719154788},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1646719154795},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1646719154788},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1646719154788},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1646719154788},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1646719154789},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1646719154789},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1646719154789},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1646719154789},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1646719154789},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1646719154789},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1646719154790},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1646719154790},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1646719154790},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1646719154794},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1646719154794},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1646719154794},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1646719154794},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1646719154795},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1646719154795},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1646719154795},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1646719154795},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"5e3b70c028d518b8f765e29a5e2020e7ba6ed589","modified":1646719154790},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1646719154790},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1646719154791},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1646719154791},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1646719154791},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1646719154791},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1646719154791},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1646719154792},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1646719154792},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1646719154792},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1646719154793},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1646719154793},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1646719154793},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1646719154793},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1646719154794},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1646719154794},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1646719154796},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1646719154798},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1646719154803},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1646719154804},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1646719154804},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1646719154804},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1646719154804},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1646719154805},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1646719154805},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1646719154806},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1646719154807},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1646719154807},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1646719154808},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1646719154792},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1646719154792},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1646719154792},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1646719154793},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1646719154793},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1646719154793},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1646719154796},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1646719154796},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1646719154796},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1646719154797},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1646719154797},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1646719154797},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1646719154797},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1646719154797},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1646719154798},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1646719154798},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1646719154798},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1646719154798},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1646719154799},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1646719154800},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1646719154801},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1646719154805},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1646719154805},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1646719154806},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1646719154806},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1646719154806},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1646719154806},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1646719154801},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1646719154801},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1646719154803},{"_id":"public/2022/03/25/Bitwise-operation-on-integers-basics-of-C/index.html","hash":"9162371b47b8202ab088d4a091a9941b66ec6263","modified":1648804346227},{"_id":"public/2022/03/22/部署项目到服务器操作流程/index.html","hash":"6666e03155fa0ce6525f328c02ae6f792576d604","modified":1648804346227},{"_id":"public/2022/02/17/first-post-from-john/index.html","hash":"12a105e812f56ddbf3d919d36aeda8fe754cb969","modified":1648804346227},{"_id":"public/archives/index.html","hash":"dd8642d3eb00fb7b86fbc9c86c774d9a050139be","modified":1648804346227},{"_id":"public/archives/2022/index.html","hash":"57ea68a093664f77e86cb215ff8e4dd661e05d25","modified":1648804346227},{"_id":"public/archives/2022/02/index.html","hash":"a8f1cb224495748af58f934bb23d61e4c28357f8","modified":1648804346227},{"_id":"public/archives/2022/03/index.html","hash":"deaf7aa82b049d2af8fa8580764c5e791ee8bbb4","modified":1648804346227},{"_id":"public/archives/2022/04/index.html","hash":"96ff1b78bbef752b176a1915ffdd6c8a19945c97","modified":1648804346227},{"_id":"public/2022/04/01/An-introduction-to-HTML-CSS-JS/index.html","hash":"dea8227feaa218dee48abe40f96250ce29d93893","modified":1648804346227},{"_id":"public/2022/03/09/electron02-调用DLL/index.html","hash":"8c9be8531f2871a0f470a960db3cf6808530cb93","modified":1648804346227},{"_id":"public/index.html","hash":"d592f5f18a67a03fb95e5ce1e7133e7c2e76678d","modified":1648804346227},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1648804346227},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1648804346227},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1648804346227},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1648804346227},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1648804346227},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1648804346227},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1648804346227},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1648804346227},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1648804346227},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1648804346227},{"_id":"public/2022/03/09/electron02-调用DLL/01.png","hash":"2b455e675b5447586456e7bb68cd685fb0e3010c","modified":1648804346227},{"_id":"public/2022/03/09/electron02-调用DLL/02.png","hash":"b1b1af829ff5735319fe83c8b37c73c18e8f2647","modified":1648804346227},{"_id":"public/2022/03/09/electron02-调用DLL/03.png","hash":"c90ecfdd8a6cc080ed5b01992fd6a6893c8715d2","modified":1648804346227},{"_id":"public/2022/03/09/electron02-调用DLL/04.png","hash":"e1ca6d20ae488b3d1272cd8e71eb836ce0bb4ca9","modified":1648804346227},{"_id":"public/2022/03/09/electron02-调用DLL/05.png","hash":"b005c9e24f5b4a2c46e09214830c0120d5b224e0","modified":1648804346227},{"_id":"public/2022/03/22/部署项目到服务器操作流程/02.png","hash":"97bc243d215f9c7e1e9eaf12ae2ff566430c8613","modified":1648804346227},{"_id":"public/2022/04/01/An-introduction-to-HTML-CSS-JS/DOM.png","hash":"9c482d4610ec60c994138419d264dc8f1b2544d5","modified":1648804346227},{"_id":"public/2022/04/01/An-introduction-to-HTML-CSS-JS/render.png","hash":"787cb81024b7980562274a9b4d5b0ccc73bfcc91","modified":1648804346227},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1648804346227},{"_id":"public/2022/03/22/部署项目到服务器操作流程/01.png","hash":"7b53927615215071037a8b56877be6ada21d5de2","modified":1648804346227},{"_id":"public/2022/04/01/An-introduction-to-HTML-CSS-JS/metaphor.png","hash":"e6f5e4409907429f61a3f06efb10b66f88b487b2","modified":1648804346227},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1648804346227},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1648804346227},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1648804346227},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1648804346227},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1648804346227},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1648804346227},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1648804346227},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1648804346227},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1648804346227},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1648804346227},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1648804346227},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1648804346227}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Bitwise operation on integers--basics of C","date":"2022-03-25T07:22:02.000Z","_content":"\n### Bit shifts << and >>\n\nThese operators simply shift the bits left or right. Starting with x=24 as shown above:\n\n    the binary code of 24(int32) is\n    00000000000000000000000000011000\n\n    x << 2\n    results in\n    00000000000000000000000001100000\n    (which is 96)\n\n    x >> 2\n    results in\n    00000000000000000000000000000110\n    (which is 6)\n\n### Hex codes (anything beginning in 0x)\n\nHex code is a number system (hexadecimal) that is easier to convert to binary because it's base 16, so every character is exactly 4 bits. For example, \"f\" becomes \"1111\" in binary, so 0xffff is sixteen 1's, which in a 32bit int looks like:\n\n    0000000000000000111111111111111111\n\n### Bitwise AND &\n\nThis takes two numbers, goes through them bit by bit, and does an AND operation on them. For example, let's imagine x is our 24, which is:\n\n    00000000000000000000000000011000\n\nNow if we do x & 0xffff, in this case it will return the same value as x, because all of the 1 bits are within the 1 bits of 0xffff.\nBut let's do a bigger \"number\" (or really, a series of bits with some of the larger 1s enabled), like:\n\n    00001111000011000000000000001111\n\nNow, x & 0xffff does something interesting. Because the first 16 bits of 0xffff are 0s, the AND operation for those is now false, so now x & 0xffff results in:\n\n    00000000000000000000000000001111\n\nIn practice in Unity you'll see this a lot in layer masks - there are 32 layers, each layer is one of these bits. So if you want to see if a given GameObject is on layer 5, you can do this:\n\n```csharp\nint someMask = 0xffff; //\"just the first 16 layers\"\nint thisLayer = gameObject.layer;\nint thisLayerAsABit = 1 << thisLayer; // shift the 1 over to the \"thisLayer\"th bit\nif (thisLayerAsABit & someMask) {\n```\n\n### Bitwise OR |\n\nThis is basically the same as bitwise AND, except with an OR operation. You can use this to combine LayerMasks, but that's not very common. Where you're more likely to see this is in enums. In C# you can create enums with specified number values, and if these number values are powers of two, you can do a neat trick where you can | them together, and a single number can contain not just a reference to a single item on the enum, but any number of items on the enum. Here's a basic example:\n\n```csharp\nenum WeaponFlags {IsMelee = 1, IsRanged = 2, IsFire = 4, IsBullet = 8; IsBomb = 16 }\n\nint isFireAndMelee = WeaponFlags.IsMelee | WeaponFlags.IsFire;\n//isFireAndMelee bits: 00000000000000000000000000000101\n```\n\n#### Reference\n\nhttps://forum.unity.com/threads/bitwise-operation-on-integers-what-does-x-16-and-x-0xffff-do-numerically.862753/\n","source":"_posts/Bitwise-operation-on-integers-basics-of-C.md","raw":"---\ntitle: Bitwise operation on integers--basics of C\ndate: 2022-03-25 15:22:02\ntags:\n---\n\n### Bit shifts << and >>\n\nThese operators simply shift the bits left or right. Starting with x=24 as shown above:\n\n    the binary code of 24(int32) is\n    00000000000000000000000000011000\n\n    x << 2\n    results in\n    00000000000000000000000001100000\n    (which is 96)\n\n    x >> 2\n    results in\n    00000000000000000000000000000110\n    (which is 6)\n\n### Hex codes (anything beginning in 0x)\n\nHex code is a number system (hexadecimal) that is easier to convert to binary because it's base 16, so every character is exactly 4 bits. For example, \"f\" becomes \"1111\" in binary, so 0xffff is sixteen 1's, which in a 32bit int looks like:\n\n    0000000000000000111111111111111111\n\n### Bitwise AND &\n\nThis takes two numbers, goes through them bit by bit, and does an AND operation on them. For example, let's imagine x is our 24, which is:\n\n    00000000000000000000000000011000\n\nNow if we do x & 0xffff, in this case it will return the same value as x, because all of the 1 bits are within the 1 bits of 0xffff.\nBut let's do a bigger \"number\" (or really, a series of bits with some of the larger 1s enabled), like:\n\n    00001111000011000000000000001111\n\nNow, x & 0xffff does something interesting. Because the first 16 bits of 0xffff are 0s, the AND operation for those is now false, so now x & 0xffff results in:\n\n    00000000000000000000000000001111\n\nIn practice in Unity you'll see this a lot in layer masks - there are 32 layers, each layer is one of these bits. So if you want to see if a given GameObject is on layer 5, you can do this:\n\n```csharp\nint someMask = 0xffff; //\"just the first 16 layers\"\nint thisLayer = gameObject.layer;\nint thisLayerAsABit = 1 << thisLayer; // shift the 1 over to the \"thisLayer\"th bit\nif (thisLayerAsABit & someMask) {\n```\n\n### Bitwise OR |\n\nThis is basically the same as bitwise AND, except with an OR operation. You can use this to combine LayerMasks, but that's not very common. Where you're more likely to see this is in enums. In C# you can create enums with specified number values, and if these number values are powers of two, you can do a neat trick where you can | them together, and a single number can contain not just a reference to a single item on the enum, but any number of items on the enum. Here's a basic example:\n\n```csharp\nenum WeaponFlags {IsMelee = 1, IsRanged = 2, IsFire = 4, IsBullet = 8; IsBomb = 16 }\n\nint isFireAndMelee = WeaponFlags.IsMelee | WeaponFlags.IsFire;\n//isFireAndMelee bits: 00000000000000000000000000000101\n```\n\n#### Reference\n\nhttps://forum.unity.com/threads/bitwise-operation-on-integers-what-does-x-16-and-x-0xffff-do-numerically.862753/\n","slug":"Bitwise-operation-on-integers-basics-of-C","published":1,"updated":"2022-03-25T08:28:10.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1g7jc1g000088tc9t8x4c74","content":"<h3 id=\"Bit-shifts-lt-lt-and-gt-gt\"><a href=\"#Bit-shifts-lt-lt-and-gt-gt\" class=\"headerlink\" title=\"Bit shifts &lt;&lt; and &gt;&gt;\"></a>Bit shifts &lt;&lt; and &gt;&gt;</h3><p>These operators simply shift the bits left or right. Starting with x=24 as shown above:</p>\n<pre><code>the binary code of 24(int32) is\n00000000000000000000000000011000\n\nx &lt;&lt; 2\nresults in\n00000000000000000000000001100000\n(which is 96)\n\nx &gt;&gt; 2\nresults in\n00000000000000000000000000000110\n(which is 6)\n</code></pre>\n<h3 id=\"Hex-codes-anything-beginning-in-0x\"><a href=\"#Hex-codes-anything-beginning-in-0x\" class=\"headerlink\" title=\"Hex codes (anything beginning in 0x)\"></a>Hex codes (anything beginning in 0x)</h3><p>Hex code is a number system (hexadecimal) that is easier to convert to binary because it’s base 16, so every character is exactly 4 bits. For example, “f” becomes “1111” in binary, so 0xffff is sixteen 1’s, which in a 32bit int looks like:</p>\n<pre><code>0000000000000000111111111111111111\n</code></pre>\n<h3 id=\"Bitwise-AND-amp\"><a href=\"#Bitwise-AND-amp\" class=\"headerlink\" title=\"Bitwise AND &amp;\"></a>Bitwise AND &amp;</h3><p>This takes two numbers, goes through them bit by bit, and does an AND operation on them. For example, let’s imagine x is our 24, which is:</p>\n<pre><code>00000000000000000000000000011000\n</code></pre>\n<p>Now if we do x &amp; 0xffff, in this case it will return the same value as x, because all of the 1 bits are within the 1 bits of 0xffff.<br>But let’s do a bigger “number” (or really, a series of bits with some of the larger 1s enabled), like:</p>\n<pre><code>00001111000011000000000000001111\n</code></pre>\n<p>Now, x &amp; 0xffff does something interesting. Because the first 16 bits of 0xffff are 0s, the AND operation for those is now false, so now x &amp; 0xffff results in:</p>\n<pre><code>00000000000000000000000000001111\n</code></pre>\n<p>In practice in Unity you’ll see this a lot in layer masks - there are 32 layers, each layer is one of these bits. So if you want to see if a given GameObject is on layer 5, you can do this:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> someMask = <span class=\"number\">0xffff</span>; <span class=\"comment\">//&quot;just the first 16 layers&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> thisLayer = gameObject.layer;</span><br><span class=\"line\"><span class=\"built_in\">int</span> thisLayerAsABit = <span class=\"number\">1</span> &lt;&lt; thisLayer; <span class=\"comment\">// shift the 1 over to the &quot;thisLayer&quot;th bit</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (thisLayerAsABit &amp; someMask) &#123;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bitwise-OR\"><a href=\"#Bitwise-OR\" class=\"headerlink\" title=\"Bitwise OR |\"></a>Bitwise OR |</h3><p>This is basically the same as bitwise AND, except with an OR operation. You can use this to combine LayerMasks, but that’s not very common. Where you’re more likely to see this is in enums. In C# you can create enums with specified number values, and if these number values are powers of two, you can do a neat trick where you can | them together, and a single number can contain not just a reference to a single item on the enum, but any number of items on the enum. Here’s a basic example:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> WeaponFlags &#123;IsMelee = <span class=\"number\">1</span>, IsRanged = <span class=\"number\">2</span>, IsFire = <span class=\"number\">4</span>, IsBullet = <span class=\"number\">8</span>; IsBomb = <span class=\"number\">16</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> isFireAndMelee = WeaponFlags.IsMelee | WeaponFlags.IsFire;</span><br><span class=\"line\"><span class=\"comment\">//isFireAndMelee bits: 00000000000000000000000000000101</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><p><a href=\"https://forum.unity.com/threads/bitwise-operation-on-integers-what-does-x-16-and-x-0xffff-do-numerically.862753/\">https://forum.unity.com/threads/bitwise-operation-on-integers-what-does-x-16-and-x-0xffff-do-numerically.862753/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Bit-shifts-lt-lt-and-gt-gt\"><a href=\"#Bit-shifts-lt-lt-and-gt-gt\" class=\"headerlink\" title=\"Bit shifts &lt;&lt; and &gt;&gt;\"></a>Bit shifts &lt;&lt; and &gt;&gt;</h3><p>These operators simply shift the bits left or right. Starting with x=24 as shown above:</p>\n<pre><code>the binary code of 24(int32) is\n00000000000000000000000000011000\n\nx &lt;&lt; 2\nresults in\n00000000000000000000000001100000\n(which is 96)\n\nx &gt;&gt; 2\nresults in\n00000000000000000000000000000110\n(which is 6)\n</code></pre>\n<h3 id=\"Hex-codes-anything-beginning-in-0x\"><a href=\"#Hex-codes-anything-beginning-in-0x\" class=\"headerlink\" title=\"Hex codes (anything beginning in 0x)\"></a>Hex codes (anything beginning in 0x)</h3><p>Hex code is a number system (hexadecimal) that is easier to convert to binary because it’s base 16, so every character is exactly 4 bits. For example, “f” becomes “1111” in binary, so 0xffff is sixteen 1’s, which in a 32bit int looks like:</p>\n<pre><code>0000000000000000111111111111111111\n</code></pre>\n<h3 id=\"Bitwise-AND-amp\"><a href=\"#Bitwise-AND-amp\" class=\"headerlink\" title=\"Bitwise AND &amp;\"></a>Bitwise AND &amp;</h3><p>This takes two numbers, goes through them bit by bit, and does an AND operation on them. For example, let’s imagine x is our 24, which is:</p>\n<pre><code>00000000000000000000000000011000\n</code></pre>\n<p>Now if we do x &amp; 0xffff, in this case it will return the same value as x, because all of the 1 bits are within the 1 bits of 0xffff.<br>But let’s do a bigger “number” (or really, a series of bits with some of the larger 1s enabled), like:</p>\n<pre><code>00001111000011000000000000001111\n</code></pre>\n<p>Now, x &amp; 0xffff does something interesting. Because the first 16 bits of 0xffff are 0s, the AND operation for those is now false, so now x &amp; 0xffff results in:</p>\n<pre><code>00000000000000000000000000001111\n</code></pre>\n<p>In practice in Unity you’ll see this a lot in layer masks - there are 32 layers, each layer is one of these bits. So if you want to see if a given GameObject is on layer 5, you can do this:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> someMask = <span class=\"number\">0xffff</span>; <span class=\"comment\">//&quot;just the first 16 layers&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> thisLayer = gameObject.layer;</span><br><span class=\"line\"><span class=\"built_in\">int</span> thisLayerAsABit = <span class=\"number\">1</span> &lt;&lt; thisLayer; <span class=\"comment\">// shift the 1 over to the &quot;thisLayer&quot;th bit</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (thisLayerAsABit &amp; someMask) &#123;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Bitwise-OR\"><a href=\"#Bitwise-OR\" class=\"headerlink\" title=\"Bitwise OR |\"></a>Bitwise OR |</h3><p>This is basically the same as bitwise AND, except with an OR operation. You can use this to combine LayerMasks, but that’s not very common. Where you’re more likely to see this is in enums. In C# you can create enums with specified number values, and if these number values are powers of two, you can do a neat trick where you can | them together, and a single number can contain not just a reference to a single item on the enum, but any number of items on the enum. Here’s a basic example:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> WeaponFlags &#123;IsMelee = <span class=\"number\">1</span>, IsRanged = <span class=\"number\">2</span>, IsFire = <span class=\"number\">4</span>, IsBullet = <span class=\"number\">8</span>; IsBomb = <span class=\"number\">16</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> isFireAndMelee = WeaponFlags.IsMelee | WeaponFlags.IsFire;</span><br><span class=\"line\"><span class=\"comment\">//isFireAndMelee bits: 00000000000000000000000000000101</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><p><a href=\"https://forum.unity.com/threads/bitwise-operation-on-integers-what-does-x-16-and-x-0xffff-do-numerically.862753/\">https://forum.unity.com/threads/bitwise-operation-on-integers-what-does-x-16-and-x-0xffff-do-numerically.862753/</a></p>\n"},{"title":"electron02--调用DLL","date":"2022-03-09T02:14:47.000Z","_content":"\n# electron 学习--调用 .dll\n\n## 引言\n\n本文使用 node-ffi/ffi-napi 调用 C/C++编写的动态链接库(即 dll)，以实现一些硬件功能。\n\n## ffi\n\n> node-ffi 是一个用于使用纯 JavaScript 加载和调用动态库的 Node.js 插件。它可以用来在不编写任何 C++代码的情况下创建与本地 DLL 库的绑定。同时它负责处理跨 JavaScript 和 C 的类型转换。\n\n-   node-ffi 连接了 C 代码和 JS 代码, 通过内存共享来完成调用, 而内部又通过 ref,ref-array 和 ref-struct 来实现类型转换.\n\n## 安装 ffi\n\n> ffi-napi 是作者(node-ffi-napi)根据 node-ffi 修改而发布到 npm 仓库的, 可以直接通过 npm 安装, 支持 node.js 12 和 electron 高版本.\n\n1. 部署 node.js+electron 环境\n   请自行参照相关教程\n\n2. 安装 ffi-napi\n\n    ```\n    yarn add ffi-napi\n    ```\n\n3. 使用 ffi\n   在`main.js`中添加以下代码：\n\n    ```js\n    const ffi = require(\"ffi-napi\");\n    /**\n     * 先定义一个函数, 用来在窗口中显示字符\n     * @param {String} text\n     * @return {*} none\n     */\n    function showText(text) {\n        return new Buffer(text, \"ucs2\").toString(\"binary\");\n    }\n    // 通过ffi加载user32.dll\n    const myUser32 = new ffi.Library(\"user32\", {\n        // 声明这个dll中的一个函数\n        MessageBoxW: [\n            \"int32\",\n            [\"int32\", \"string\", \"string\", \"int32\"], // 用json的格式罗列其返回类型和参数类型\n        ],\n    });\n\n    // 调用user32.dll中的MessageBoxW()函数, 弹出一个对话框\n    const isOk = myUser32.MessageBoxW(\n        0,\n        showText(\"I am Node.JS!\"),\n        showText(\"Hello, World!\"),\n        1\n    );\n    console.log(isOk);\n    ```\n\n    启动程序：\n\n    ```\n    yarn start\n    ```\n\n    启动成功！出现了弹窗：\n\n    ![01](01.png)\n\n## 自己生成一个 dll\n\n0. 开始之前\n\n-   注意：\n\n    > ffi 只接受纯 C 函数, 确切的说, 是按照 C 标准编译的函数\n\n    下面来说说具体的原因:\n\n    在通过 ffi 引入 dll 的时候, 我们是这么声明的:\n\n    ```js\n    const myUser32 = new ffi.Library(\"user32\", {\n        // 声明这个dll中的一个函数\n        MessageBoxW: [\n            \"int32\",\n            [\"int32\", \"string\", \"string\", \"int32\"], // 用json的格式罗列其返回类型和参数类型\n        ],\n    });\n    ```\n\n    在`user32.dll`中, 寻找一个名字叫`MessageBoxW`的函数.\n\n    但是, C 和 C++的函数命名是不同的, 我指的是编译后的函数名字\n\n    对于 C, 函数`int func(int n)`会被编译为类似`_func`这样的名字.\n\n    对于 C++, 函数`int func(int n)`会被编译为类似`?func@@YAHH@Z`这样的名字.\n\n    同样是 C++, 函数`int func(int double)`会被编译为类似`?func@@YAHN@Z`这样的名字(和上一个不同).\n\n    名字中包含了较多信息, 比如:\n\n    > 参数的入栈方式\n    > 返回值的类型\n    > 参数的类型和数量\n\n    这是因为 C++有`函数重载`特性, 虽然函数命名是`func`, 但`int func(int n)`和`int func(int double)`完全是两个不同的函数, 编译器通过给它们赋予不同的名字来区分它们.ffi 在 dll 中查找函数名字的时候, **是用 C 风格来查找的**.\n\n    -   所以,如果你的函数使用 C++编译的, ffl 在这个 dll 中就找不到这个函数, 会出现错误`LINK 126`!\n\n1.  创建工程\n\n    使用 VS 创建一个 C++ **空项目**即可. 项目名成以 myDLL 为例（当然, 你也可以直接创建动态链接库 DLL）:\n\n    ![02](02.png)\n\n2.  函数声明\n    创建一个 myAdd.h 头文件，并声明一个`funAdd`函数：\n\n    ```c++\n    extern \"C\"\n    {\n        __declspec(dllexport) int funAdd(int a, int b);\n    }\n    ```\n\n    `extern \"C\"`的含义:\n\n    > 被 extern \"C\" 修饰的变量和函数是按照 C 语言方式编译和链接的\n\n    `__declspec(dllexport)`的含义:\n\n    > \\_\\_declspec(dllexport)用于 Windows 中的动态库中，声明导出函数、类、对象等供外面调用，省略给出.def 文件。即将函数、类等声明为导出函数，供其它程序调用，作为动态库的对外接口函数、类等。\n\n3.  函数定义\n\n    创建一个 myAdd.cpp 源文件，定义一个`funAdd`函数：\n\n    ```c++\n    #include \"myAdd.h\"\n    int funAdd(int a, int b)\n    {\n    return (a + b);\n    }\n    ```\n\n    创建完 myAdd.h 和 myAdd.cpp 如下图所示：\n\n    ![04](04.png)\n\n4.  修改配置类型为动态库.dll\n    在项目配置中, 选择生成动态库.dll(确保你配置了 Debug 和 Release, 同时确保你在 x64 环境下生成):\n\n    ![03](03.png)\n\n5.  生成 dll\n    右键项目选择生成即可, 生成的 myDLL.dll 位于项目目录下的 x64/Debug 中(根据你项目的配置去找, x64 或 x86, Debug 或 Release)。\n\n6.  测试 dll\n    将 myDLL.dll 拷贝至你的 electron 项目的根目录下的 dll 文件夹内\n    在`main.js`中添加如下代码:\n\n    ```js\n    const ffi = require(\"ffi-napi\"); // 如果前面已经定义过ffi, 就注释掉这一行\n    // myDLL.dll\n    const myDLL = new ffi.Library(\"/myDLL\", {\n        // 声明这个dll中的一个函数\n        funAdd: [\n            \"int\",\n            [\"int\", \"int\"], // 用json的格式罗列其返回类型和参数类型\n        ],\n    });\n\n    // 调用函数, 参数1和2, 将返回值直接打印出来, 预计为3\n    const result = myDLL.funAdd(1, 2);\n    console.log(`the result of 1 + 2 is: ` + result);\n    ```\n\n    启动程序：\n\n    ```\n    yarn start\n    ```\n\n    启动成功！shell 里打印出了相应的结果：\n\n    ![05](05.png)\n\n-   上面代码中，`ffi.Library`里第二个参数是一个 Json 结构，key 为方法名，value 为一个数组，数组的第一个参数是**返回值类型**，第二个参数是包含所有**传参类型**的子数组，如：如果返回值是空的话，那数组第一个参数应该是 void。如果返回值或者参数类型不知道是什么类型就写 void\\*。要使用 ffi 中的类型表示 C/C++语言中的类型，对照表如下：\n\n    > 基本类型\n    > int8--Signed 8-bit Integer\n    > uint8--Unsigned 8-bit Integer\n    > int16--Signed 16-bit Integer\n    > uint16--Unsigned 16-bit Integer\n    > int32--Signed 32-bit Integer\n    > uint32--Unsigned 32-bit Integer\n    > int64--Signed 64-bit Integer\n    > uint64--Unsigned 64-bit Integer\n    > float--Single Precision Floating Point Number (float)\n    > double--Double Precision Floating Point Number (double)\n    > pointer--Pointer Type\n    > string--Null-Terminated String (char \\*)\n    > 常见的 C 语言类型\n    > byte--unsigned char\n    > char--char\n    > uchar--unsigned char\n    > short--short\n    > ushort--unsigned short\n    > int--int\n    > uint--unsigned int\n    > long--long\n    > ulong--unsigned long\n    > longlong--long\n    > ulonglong--unsigned long long\n    > size_t--platform-dependent, usually pointer size\n\n    如果是指针类型，可以引入`ref-napi`和`ref-array`模块来表示\n\n    ```js\n    var ref = require(\"ref-napi\");\n    var refArray = require(\"ref-array\");\n\n    var intPtr = ref.refType(\"int\"); //int*类型\n    var charPtr = \"hello\"; //char*可以用string表示\n\n    //如果是个字符数组\n    var refArray = require(\"ref-array\");\n    var charPtrPtr = refArray(ref.types.char, 50); //50个大小的数组\n    ```\n\n    假如参数或者返回值是一个结构体，那就需要借助`ref-struct`模块来表示\n\n    ```js\n    var ref = require(\"ref-napi\");\n    var FFI = require(\"ffi-napi\");\n    var Struct = require(\"ref-struct\");\n\n    var TimeVal = Struct({\n        tv_sec: \"long\",\n        tv_usec: \"long\",\n    });\n    var TimeValPtr = ref.refType(TimeVal);\n    var lib = new FFI.Library(null, {\n        gettimeofday: [\"int\", [TimeValPtr, \"pointer\"]],\n    });\n    var tv = new TimeVal();\n    lib.gettimeofday(tv.ref(), null);\n    console.log(\"Seconds since epoch: \" + tv.tv_sec);\n    ```\n\n    **注：更多 ref 插件的方法详见 ref 文档： https://tootallnate.github.io/ref/**\n\n    ## 可能出现的错误\n\n    > 错误 1：LINK 126\n\n    这个错误, 意味者 electron 无法使用你的 dll.\n\n    ```js\n    const myDLL = new ffi.Library('/myDLL', {\n    ```\n\n    在上面这行代码中，`ffi.Library`的第一个参数, 不光指定了 dll 的名字, 还指定了 dll 的路径.\n    出现 LINK 126 有两个常见原因:\n\n    1. 没有这个**目录**, 或这个目录下没有 `myDLL.dll`\n    2. `myDLL.dll` 还**依赖了其他**的一些 dll, 但是 electron 无法找到这个 dll.\n\n    > 错误 2：LINK 127\n\n    出现 LINK 127 的可能原因:\n\n    1. electron 找到了你的 dll, 但是在 dll 中**找不到**你声名的函数(funAdd)。这通常是由于**函数名字错误**, 或者是**返回值类型**/**参数的个数**及**类型**不一致导致的.\n\n## References\n\n1. https://www.cnblogs.com/silenzio/p/11606389.html\n2. https://segmentfault.com/a/1190000019402908?utm_source=tag-newest\n","source":"_posts/electron02-调用DLL.md","raw":"---\ntitle: electron02--调用DLL\ndate: 2022-03-09 10:14:47\ntags:\n---\n\n# electron 学习--调用 .dll\n\n## 引言\n\n本文使用 node-ffi/ffi-napi 调用 C/C++编写的动态链接库(即 dll)，以实现一些硬件功能。\n\n## ffi\n\n> node-ffi 是一个用于使用纯 JavaScript 加载和调用动态库的 Node.js 插件。它可以用来在不编写任何 C++代码的情况下创建与本地 DLL 库的绑定。同时它负责处理跨 JavaScript 和 C 的类型转换。\n\n-   node-ffi 连接了 C 代码和 JS 代码, 通过内存共享来完成调用, 而内部又通过 ref,ref-array 和 ref-struct 来实现类型转换.\n\n## 安装 ffi\n\n> ffi-napi 是作者(node-ffi-napi)根据 node-ffi 修改而发布到 npm 仓库的, 可以直接通过 npm 安装, 支持 node.js 12 和 electron 高版本.\n\n1. 部署 node.js+electron 环境\n   请自行参照相关教程\n\n2. 安装 ffi-napi\n\n    ```\n    yarn add ffi-napi\n    ```\n\n3. 使用 ffi\n   在`main.js`中添加以下代码：\n\n    ```js\n    const ffi = require(\"ffi-napi\");\n    /**\n     * 先定义一个函数, 用来在窗口中显示字符\n     * @param {String} text\n     * @return {*} none\n     */\n    function showText(text) {\n        return new Buffer(text, \"ucs2\").toString(\"binary\");\n    }\n    // 通过ffi加载user32.dll\n    const myUser32 = new ffi.Library(\"user32\", {\n        // 声明这个dll中的一个函数\n        MessageBoxW: [\n            \"int32\",\n            [\"int32\", \"string\", \"string\", \"int32\"], // 用json的格式罗列其返回类型和参数类型\n        ],\n    });\n\n    // 调用user32.dll中的MessageBoxW()函数, 弹出一个对话框\n    const isOk = myUser32.MessageBoxW(\n        0,\n        showText(\"I am Node.JS!\"),\n        showText(\"Hello, World!\"),\n        1\n    );\n    console.log(isOk);\n    ```\n\n    启动程序：\n\n    ```\n    yarn start\n    ```\n\n    启动成功！出现了弹窗：\n\n    ![01](01.png)\n\n## 自己生成一个 dll\n\n0. 开始之前\n\n-   注意：\n\n    > ffi 只接受纯 C 函数, 确切的说, 是按照 C 标准编译的函数\n\n    下面来说说具体的原因:\n\n    在通过 ffi 引入 dll 的时候, 我们是这么声明的:\n\n    ```js\n    const myUser32 = new ffi.Library(\"user32\", {\n        // 声明这个dll中的一个函数\n        MessageBoxW: [\n            \"int32\",\n            [\"int32\", \"string\", \"string\", \"int32\"], // 用json的格式罗列其返回类型和参数类型\n        ],\n    });\n    ```\n\n    在`user32.dll`中, 寻找一个名字叫`MessageBoxW`的函数.\n\n    但是, C 和 C++的函数命名是不同的, 我指的是编译后的函数名字\n\n    对于 C, 函数`int func(int n)`会被编译为类似`_func`这样的名字.\n\n    对于 C++, 函数`int func(int n)`会被编译为类似`?func@@YAHH@Z`这样的名字.\n\n    同样是 C++, 函数`int func(int double)`会被编译为类似`?func@@YAHN@Z`这样的名字(和上一个不同).\n\n    名字中包含了较多信息, 比如:\n\n    > 参数的入栈方式\n    > 返回值的类型\n    > 参数的类型和数量\n\n    这是因为 C++有`函数重载`特性, 虽然函数命名是`func`, 但`int func(int n)`和`int func(int double)`完全是两个不同的函数, 编译器通过给它们赋予不同的名字来区分它们.ffi 在 dll 中查找函数名字的时候, **是用 C 风格来查找的**.\n\n    -   所以,如果你的函数使用 C++编译的, ffl 在这个 dll 中就找不到这个函数, 会出现错误`LINK 126`!\n\n1.  创建工程\n\n    使用 VS 创建一个 C++ **空项目**即可. 项目名成以 myDLL 为例（当然, 你也可以直接创建动态链接库 DLL）:\n\n    ![02](02.png)\n\n2.  函数声明\n    创建一个 myAdd.h 头文件，并声明一个`funAdd`函数：\n\n    ```c++\n    extern \"C\"\n    {\n        __declspec(dllexport) int funAdd(int a, int b);\n    }\n    ```\n\n    `extern \"C\"`的含义:\n\n    > 被 extern \"C\" 修饰的变量和函数是按照 C 语言方式编译和链接的\n\n    `__declspec(dllexport)`的含义:\n\n    > \\_\\_declspec(dllexport)用于 Windows 中的动态库中，声明导出函数、类、对象等供外面调用，省略给出.def 文件。即将函数、类等声明为导出函数，供其它程序调用，作为动态库的对外接口函数、类等。\n\n3.  函数定义\n\n    创建一个 myAdd.cpp 源文件，定义一个`funAdd`函数：\n\n    ```c++\n    #include \"myAdd.h\"\n    int funAdd(int a, int b)\n    {\n    return (a + b);\n    }\n    ```\n\n    创建完 myAdd.h 和 myAdd.cpp 如下图所示：\n\n    ![04](04.png)\n\n4.  修改配置类型为动态库.dll\n    在项目配置中, 选择生成动态库.dll(确保你配置了 Debug 和 Release, 同时确保你在 x64 环境下生成):\n\n    ![03](03.png)\n\n5.  生成 dll\n    右键项目选择生成即可, 生成的 myDLL.dll 位于项目目录下的 x64/Debug 中(根据你项目的配置去找, x64 或 x86, Debug 或 Release)。\n\n6.  测试 dll\n    将 myDLL.dll 拷贝至你的 electron 项目的根目录下的 dll 文件夹内\n    在`main.js`中添加如下代码:\n\n    ```js\n    const ffi = require(\"ffi-napi\"); // 如果前面已经定义过ffi, 就注释掉这一行\n    // myDLL.dll\n    const myDLL = new ffi.Library(\"/myDLL\", {\n        // 声明这个dll中的一个函数\n        funAdd: [\n            \"int\",\n            [\"int\", \"int\"], // 用json的格式罗列其返回类型和参数类型\n        ],\n    });\n\n    // 调用函数, 参数1和2, 将返回值直接打印出来, 预计为3\n    const result = myDLL.funAdd(1, 2);\n    console.log(`the result of 1 + 2 is: ` + result);\n    ```\n\n    启动程序：\n\n    ```\n    yarn start\n    ```\n\n    启动成功！shell 里打印出了相应的结果：\n\n    ![05](05.png)\n\n-   上面代码中，`ffi.Library`里第二个参数是一个 Json 结构，key 为方法名，value 为一个数组，数组的第一个参数是**返回值类型**，第二个参数是包含所有**传参类型**的子数组，如：如果返回值是空的话，那数组第一个参数应该是 void。如果返回值或者参数类型不知道是什么类型就写 void\\*。要使用 ffi 中的类型表示 C/C++语言中的类型，对照表如下：\n\n    > 基本类型\n    > int8--Signed 8-bit Integer\n    > uint8--Unsigned 8-bit Integer\n    > int16--Signed 16-bit Integer\n    > uint16--Unsigned 16-bit Integer\n    > int32--Signed 32-bit Integer\n    > uint32--Unsigned 32-bit Integer\n    > int64--Signed 64-bit Integer\n    > uint64--Unsigned 64-bit Integer\n    > float--Single Precision Floating Point Number (float)\n    > double--Double Precision Floating Point Number (double)\n    > pointer--Pointer Type\n    > string--Null-Terminated String (char \\*)\n    > 常见的 C 语言类型\n    > byte--unsigned char\n    > char--char\n    > uchar--unsigned char\n    > short--short\n    > ushort--unsigned short\n    > int--int\n    > uint--unsigned int\n    > long--long\n    > ulong--unsigned long\n    > longlong--long\n    > ulonglong--unsigned long long\n    > size_t--platform-dependent, usually pointer size\n\n    如果是指针类型，可以引入`ref-napi`和`ref-array`模块来表示\n\n    ```js\n    var ref = require(\"ref-napi\");\n    var refArray = require(\"ref-array\");\n\n    var intPtr = ref.refType(\"int\"); //int*类型\n    var charPtr = \"hello\"; //char*可以用string表示\n\n    //如果是个字符数组\n    var refArray = require(\"ref-array\");\n    var charPtrPtr = refArray(ref.types.char, 50); //50个大小的数组\n    ```\n\n    假如参数或者返回值是一个结构体，那就需要借助`ref-struct`模块来表示\n\n    ```js\n    var ref = require(\"ref-napi\");\n    var FFI = require(\"ffi-napi\");\n    var Struct = require(\"ref-struct\");\n\n    var TimeVal = Struct({\n        tv_sec: \"long\",\n        tv_usec: \"long\",\n    });\n    var TimeValPtr = ref.refType(TimeVal);\n    var lib = new FFI.Library(null, {\n        gettimeofday: [\"int\", [TimeValPtr, \"pointer\"]],\n    });\n    var tv = new TimeVal();\n    lib.gettimeofday(tv.ref(), null);\n    console.log(\"Seconds since epoch: \" + tv.tv_sec);\n    ```\n\n    **注：更多 ref 插件的方法详见 ref 文档： https://tootallnate.github.io/ref/**\n\n    ## 可能出现的错误\n\n    > 错误 1：LINK 126\n\n    这个错误, 意味者 electron 无法使用你的 dll.\n\n    ```js\n    const myDLL = new ffi.Library('/myDLL', {\n    ```\n\n    在上面这行代码中，`ffi.Library`的第一个参数, 不光指定了 dll 的名字, 还指定了 dll 的路径.\n    出现 LINK 126 有两个常见原因:\n\n    1. 没有这个**目录**, 或这个目录下没有 `myDLL.dll`\n    2. `myDLL.dll` 还**依赖了其他**的一些 dll, 但是 electron 无法找到这个 dll.\n\n    > 错误 2：LINK 127\n\n    出现 LINK 127 的可能原因:\n\n    1. electron 找到了你的 dll, 但是在 dll 中**找不到**你声名的函数(funAdd)。这通常是由于**函数名字错误**, 或者是**返回值类型**/**参数的个数**及**类型**不一致导致的.\n\n## References\n\n1. https://www.cnblogs.com/silenzio/p/11606389.html\n2. https://segmentfault.com/a/1190000019402908?utm_source=tag-newest\n","slug":"electron02-调用DLL","published":1,"updated":"2022-03-25T08:32:41.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1g7jc1l000188tc9w87bc3f","content":"<h1 id=\"electron-学习–调用-dll\"><a href=\"#electron-学习–调用-dll\" class=\"headerlink\" title=\"electron 学习–调用 .dll\"></a>electron 学习–调用 .dll</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>本文使用 node-ffi/ffi-napi 调用 C/C++编写的动态链接库(即 dll)，以实现一些硬件功能。</p>\n<h2 id=\"ffi\"><a href=\"#ffi\" class=\"headerlink\" title=\"ffi\"></a>ffi</h2><blockquote>\n<p>node-ffi 是一个用于使用纯 JavaScript 加载和调用动态库的 Node.js 插件。它可以用来在不编写任何 C++代码的情况下创建与本地 DLL 库的绑定。同时它负责处理跨 JavaScript 和 C 的类型转换。</p>\n</blockquote>\n<ul>\n<li>  node-ffi 连接了 C 代码和 JS 代码, 通过内存共享来完成调用, 而内部又通过 ref,ref-array 和 ref-struct 来实现类型转换.</li>\n</ul>\n<h2 id=\"安装-ffi\"><a href=\"#安装-ffi\" class=\"headerlink\" title=\"安装 ffi\"></a>安装 ffi</h2><blockquote>\n<p>ffi-napi 是作者(node-ffi-napi)根据 node-ffi 修改而发布到 npm 仓库的, 可以直接通过 npm 安装, 支持 node.js 12 和 electron 高版本.</p>\n</blockquote>\n<ol>\n<li><p>部署 node.js+electron 环境<br>请自行参照相关教程</p>\n</li>\n<li><p>安装 ffi-napi</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add ffi-napi</span><br></pre></td></tr></table></figure></li>\n<li><p>使用 ffi<br>在<code>main.js</code>中添加以下代码：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ffi = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ffi-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 先定义一个函数, 用来在窗口中显示字符</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">String</span>&#125; <span class=\"variable\">text</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">*</span>&#125; <span class=\"variable\">none</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showText</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Buffer</span>(text, <span class=\"string\">&quot;ucs2&quot;</span>).<span class=\"title function_\">toString</span>(<span class=\"string\">&quot;binary&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过ffi加载user32.dll</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myUser32 = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&quot;user32&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明这个dll中的一个函数</span></span><br><span class=\"line\">    <span class=\"title class_\">MessageBoxW</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;int32&quot;</span>,</span><br><span class=\"line\">        [<span class=\"string\">&quot;int32&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;int32&quot;</span>], <span class=\"comment\">// 用json的格式罗列其返回类型和参数类型</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用user32.dll中的MessageBoxW()函数, 弹出一个对话框</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOk = myUser32.<span class=\"title class_\">MessageBoxW</span>(</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"title function_\">showText</span>(<span class=\"string\">&quot;I am Node.JS!&quot;</span>),</span><br><span class=\"line\">    <span class=\"title function_\">showText</span>(<span class=\"string\">&quot;Hello, World!&quot;</span>),</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(isOk);</span><br></pre></td></tr></table></figure>\n\n<p> 启动程序：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn start</span><br></pre></td></tr></table></figure>\n\n<p> 启动成功！出现了弹窗：</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/01.png\" alt=\"01\"></p>\n</li>\n</ol>\n<h2 id=\"自己生成一个-dll\"><a href=\"#自己生成一个-dll\" class=\"headerlink\" title=\"自己生成一个 dll\"></a>自己生成一个 dll</h2><ol start=\"0\">\n<li>开始之前</li>\n</ol>\n<ul>\n<li><p>注意：</p>\n<blockquote>\n<p>ffi 只接受纯 C 函数, 确切的说, 是按照 C 标准编译的函数</p>\n</blockquote>\n<p>  下面来说说具体的原因:</p>\n<p>  在通过 ffi 引入 dll 的时候, 我们是这么声明的:</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myUser32 = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&quot;user32&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明这个dll中的一个函数</span></span><br><span class=\"line\">    <span class=\"title class_\">MessageBoxW</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;int32&quot;</span>,</span><br><span class=\"line\">        [<span class=\"string\">&quot;int32&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;int32&quot;</span>], <span class=\"comment\">// 用json的格式罗列其返回类型和参数类型</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>  在<code>user32.dll</code>中, 寻找一个名字叫<code>MessageBoxW</code>的函数.</p>\n<p>  但是, C 和 C++的函数命名是不同的, 我指的是编译后的函数名字</p>\n<p>  对于 C, 函数<code>int func(int n)</code>会被编译为类似<code>_func</code>这样的名字.</p>\n<p>  对于 C++, 函数<code>int func(int n)</code>会被编译为类似<code>?func@@YAHH@Z</code>这样的名字.</p>\n<p>  同样是 C++, 函数<code>int func(int double)</code>会被编译为类似<code>?func@@YAHN@Z</code>这样的名字(和上一个不同).</p>\n<p>  名字中包含了较多信息, 比如:</p>\n<blockquote>\n<p>参数的入栈方式<br>返回值的类型<br>参数的类型和数量</p>\n</blockquote>\n<p>  这是因为 C++有<code>函数重载</code>特性, 虽然函数命名是<code>func</code>, 但<code>int func(int n)</code>和<code>int func(int double)</code>完全是两个不同的函数, 编译器通过给它们赋予不同的名字来区分它们.ffi 在 dll 中查找函数名字的时候, <strong>是用 C 风格来查找的</strong>.</p>\n<ul>\n<li>  所以,如果你的函数使用 C++编译的, ffl 在这个 dll 中就找不到这个函数, 会出现错误<code>LINK 126</code>!</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>创建工程</p>\n<p> 使用 VS 创建一个 C++ <strong>空项目</strong>即可. 项目名成以 myDLL 为例（当然, 你也可以直接创建动态链接库 DLL）:</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/02.png\" alt=\"02\"></p>\n</li>\n<li><p>函数声明<br> 创建一个 myAdd.h 头文件，并声明一个<code>funAdd</code>函数：</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __declspec(dllexport) <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">funAdd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>extern &quot;C&quot;</code>的含义:</p>\n<blockquote>\n<p>被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的</p>\n</blockquote>\n<p> <code>__declspec(dllexport)</code>的含义:</p>\n<blockquote>\n<p>__declspec(dllexport)用于 Windows 中的动态库中，声明导出函数、类、对象等供外面调用，省略给出.def 文件。即将函数、类等声明为导出函数，供其它程序调用，作为动态库的对外接口函数、类等。</p>\n</blockquote>\n</li>\n<li><p>函数定义</p>\n<p> 创建一个 myAdd.cpp 源文件，定义一个<code>funAdd</code>函数：</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;myAdd.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">funAdd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (a + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 创建完 myAdd.h 和 myAdd.cpp 如下图所示：</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/04.png\" alt=\"04\"></p>\n</li>\n<li><p>修改配置类型为动态库.dll<br> 在项目配置中, 选择生成动态库.dll(确保你配置了 Debug 和 Release, 同时确保你在 x64 环境下生成):</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/03.png\" alt=\"03\"></p>\n</li>\n<li><p>生成 dll<br> 右键项目选择生成即可, 生成的 myDLL.dll 位于项目目录下的 x64/Debug 中(根据你项目的配置去找, x64 或 x86, Debug 或 Release)。</p>\n</li>\n<li><p>测试 dll<br> 将 myDLL.dll 拷贝至你的 electron 项目的根目录下的 dll 文件夹内<br> 在<code>main.js</code>中添加如下代码:</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ffi = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ffi-napi&quot;</span>); <span class=\"comment\">// 如果前面已经定义过ffi, 就注释掉这一行</span></span><br><span class=\"line\"><span class=\"comment\">// myDLL.dll</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myDLL = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&quot;/myDLL&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明这个dll中的一个函数</span></span><br><span class=\"line\">    <span class=\"attr\">funAdd</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;int&quot;</span>,</span><br><span class=\"line\">        [<span class=\"string\">&quot;int&quot;</span>, <span class=\"string\">&quot;int&quot;</span>], <span class=\"comment\">// 用json的格式罗列其返回类型和参数类型</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用函数, 参数1和2, 将返回值直接打印出来, 预计为3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = myDLL.<span class=\"title function_\">funAdd</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`the result of 1 + 2 is: `</span> + result);</span><br></pre></td></tr></table></figure>\n\n<p> 启动程序：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn start</span><br></pre></td></tr></table></figure>\n\n<p> 启动成功！shell 里打印出了相应的结果：</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/05.png\" alt=\"05\"></p>\n</li>\n</ol>\n<ul>\n<li><p>上面代码中，<code>ffi.Library</code>里第二个参数是一个 Json 结构，key 为方法名，value 为一个数组，数组的第一个参数是<strong>返回值类型</strong>，第二个参数是包含所有<strong>传参类型</strong>的子数组，如：如果返回值是空的话，那数组第一个参数应该是 void。如果返回值或者参数类型不知道是什么类型就写 void*。要使用 ffi 中的类型表示 C/C++语言中的类型，对照表如下：</p>\n<blockquote>\n<p>基本类型<br>int8–Signed 8-bit Integer<br>uint8–Unsigned 8-bit Integer<br>int16–Signed 16-bit Integer<br>uint16–Unsigned 16-bit Integer<br>int32–Signed 32-bit Integer<br>uint32–Unsigned 32-bit Integer<br>int64–Signed 64-bit Integer<br>uint64–Unsigned 64-bit Integer<br>float–Single Precision Floating Point Number (float)<br>double–Double Precision Floating Point Number (double)<br>pointer–Pointer Type<br>string–Null-Terminated String (char *)<br>常见的 C 语言类型<br>byte–unsigned char<br>char–char<br>uchar–unsigned char<br>short–short<br>ushort–unsigned short<br>int–int<br>uint–unsigned int<br>long–long<br>ulong–unsigned long<br>longlong–long<br>ulonglong–unsigned long long<br>size_t–platform-dependent, usually pointer size</p>\n</blockquote>\n<p>  如果是指针类型，可以引入<code>ref-napi</code>和<code>ref-array</code>模块来表示</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> refArray = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-array&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> intPtr = ref.<span class=\"title function_\">refType</span>(<span class=\"string\">&quot;int&quot;</span>); <span class=\"comment\">//int*类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> charPtr = <span class=\"string\">&quot;hello&quot;</span>; <span class=\"comment\">//char*可以用string表示</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果是个字符数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> refArray = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-array&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> charPtrPtr = <span class=\"title function_\">refArray</span>(ref.<span class=\"property\">types</span>.<span class=\"property\">char</span>, <span class=\"number\">50</span>); <span class=\"comment\">//50个大小的数组</span></span><br></pre></td></tr></table></figure>\n\n<p>  假如参数或者返回值是一个结构体，那就需要借助<code>ref-struct</code>模块来表示</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"variable constant_\">FFI</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ffi-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Struct</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-struct&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">TimeVal</span> = <span class=\"title class_\">Struct</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">tv_sec</span>: <span class=\"string\">&quot;long&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">tv_usec</span>: <span class=\"string\">&quot;long&quot;</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">TimeValPtr</span> = ref.<span class=\"title function_\">refType</span>(<span class=\"title class_\">TimeVal</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"keyword\">new</span> <span class=\"variable constant_\">FFI</span>.<span class=\"title class_\">Library</span>(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">gettimeofday</span>: [<span class=\"string\">&quot;int&quot;</span>, [<span class=\"title class_\">TimeValPtr</span>, <span class=\"string\">&quot;pointer&quot;</span>]],</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tv = <span class=\"keyword\">new</span> <span class=\"title class_\">TimeVal</span>();</span><br><span class=\"line\">lib.<span class=\"title function_\">gettimeofday</span>(tv.<span class=\"title function_\">ref</span>(), <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Seconds since epoch: &quot;</span> + tv.<span class=\"property\">tv_sec</span>);</span><br></pre></td></tr></table></figure>\n\n<p>  <strong>注：更多 ref 插件的方法详见 ref 文档： <a href=\"https://tootallnate.github.io/ref/\">https://tootallnate.github.io/ref/</a></strong></p>\n<h2 id=\"可能出现的错误\"><a href=\"#可能出现的错误\" class=\"headerlink\" title=\"可能出现的错误\"></a>可能出现的错误</h2><blockquote>\n<p>错误 1：LINK 126</p>\n</blockquote>\n<p>  这个错误, 意味者 electron 无法使用你的 dll.</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myDLL = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&#x27;/myDLL&#x27;</span>, &#123;</span><br></pre></td></tr></table></figure>\n\n<p>  在上面这行代码中，<code>ffi.Library</code>的第一个参数, 不光指定了 dll 的名字, 还指定了 dll 的路径.<br>  出现 LINK 126 有两个常见原因:</p>\n<ol>\n<li>没有这个<strong>目录</strong>, 或这个目录下没有 <code>myDLL.dll</code></li>\n<li><code>myDLL.dll</code> 还<strong>依赖了其他</strong>的一些 dll, 但是 electron 无法找到这个 dll.</li>\n</ol>\n<blockquote>\n<p>错误 2：LINK 127</p>\n</blockquote>\n<p>  出现 LINK 127 的可能原因:</p>\n<ol>\n<li>electron 找到了你的 dll, 但是在 dll 中<strong>找不到</strong>你声名的函数(funAdd)。这通常是由于<strong>函数名字错误</strong>, 或者是<strong>返回值类型</strong>/<strong>参数的个数</strong>及<strong>类型</strong>不一致导致的.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ol>\n<li><a href=\"https://www.cnblogs.com/silenzio/p/11606389.html\">https://www.cnblogs.com/silenzio/p/11606389.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019402908?utm_source=tag-newest\">https://segmentfault.com/a/1190000019402908?utm_source=tag-newest</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"electron-学习–调用-dll\"><a href=\"#electron-学习–调用-dll\" class=\"headerlink\" title=\"electron 学习–调用 .dll\"></a>electron 学习–调用 .dll</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>本文使用 node-ffi/ffi-napi 调用 C/C++编写的动态链接库(即 dll)，以实现一些硬件功能。</p>\n<h2 id=\"ffi\"><a href=\"#ffi\" class=\"headerlink\" title=\"ffi\"></a>ffi</h2><blockquote>\n<p>node-ffi 是一个用于使用纯 JavaScript 加载和调用动态库的 Node.js 插件。它可以用来在不编写任何 C++代码的情况下创建与本地 DLL 库的绑定。同时它负责处理跨 JavaScript 和 C 的类型转换。</p>\n</blockquote>\n<ul>\n<li>  node-ffi 连接了 C 代码和 JS 代码, 通过内存共享来完成调用, 而内部又通过 ref,ref-array 和 ref-struct 来实现类型转换.</li>\n</ul>\n<h2 id=\"安装-ffi\"><a href=\"#安装-ffi\" class=\"headerlink\" title=\"安装 ffi\"></a>安装 ffi</h2><blockquote>\n<p>ffi-napi 是作者(node-ffi-napi)根据 node-ffi 修改而发布到 npm 仓库的, 可以直接通过 npm 安装, 支持 node.js 12 和 electron 高版本.</p>\n</blockquote>\n<ol>\n<li><p>部署 node.js+electron 环境<br>请自行参照相关教程</p>\n</li>\n<li><p>安装 ffi-napi</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add ffi-napi</span><br></pre></td></tr></table></figure></li>\n<li><p>使用 ffi<br>在<code>main.js</code>中添加以下代码：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ffi = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ffi-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 先定义一个函数, 用来在窗口中显示字符</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">String</span>&#125; <span class=\"variable\">text</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">*</span>&#125; <span class=\"variable\">none</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showText</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Buffer</span>(text, <span class=\"string\">&quot;ucs2&quot;</span>).<span class=\"title function_\">toString</span>(<span class=\"string\">&quot;binary&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过ffi加载user32.dll</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myUser32 = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&quot;user32&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明这个dll中的一个函数</span></span><br><span class=\"line\">    <span class=\"title class_\">MessageBoxW</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;int32&quot;</span>,</span><br><span class=\"line\">        [<span class=\"string\">&quot;int32&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;int32&quot;</span>], <span class=\"comment\">// 用json的格式罗列其返回类型和参数类型</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用user32.dll中的MessageBoxW()函数, 弹出一个对话框</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOk = myUser32.<span class=\"title class_\">MessageBoxW</span>(</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"title function_\">showText</span>(<span class=\"string\">&quot;I am Node.JS!&quot;</span>),</span><br><span class=\"line\">    <span class=\"title function_\">showText</span>(<span class=\"string\">&quot;Hello, World!&quot;</span>),</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(isOk);</span><br></pre></td></tr></table></figure>\n\n<p> 启动程序：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn start</span><br></pre></td></tr></table></figure>\n\n<p> 启动成功！出现了弹窗：</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/01.png\" alt=\"01\"></p>\n</li>\n</ol>\n<h2 id=\"自己生成一个-dll\"><a href=\"#自己生成一个-dll\" class=\"headerlink\" title=\"自己生成一个 dll\"></a>自己生成一个 dll</h2><ol start=\"0\">\n<li>开始之前</li>\n</ol>\n<ul>\n<li><p>注意：</p>\n<blockquote>\n<p>ffi 只接受纯 C 函数, 确切的说, 是按照 C 标准编译的函数</p>\n</blockquote>\n<p>  下面来说说具体的原因:</p>\n<p>  在通过 ffi 引入 dll 的时候, 我们是这么声明的:</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myUser32 = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&quot;user32&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明这个dll中的一个函数</span></span><br><span class=\"line\">    <span class=\"title class_\">MessageBoxW</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;int32&quot;</span>,</span><br><span class=\"line\">        [<span class=\"string\">&quot;int32&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"string\">&quot;int32&quot;</span>], <span class=\"comment\">// 用json的格式罗列其返回类型和参数类型</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>  在<code>user32.dll</code>中, 寻找一个名字叫<code>MessageBoxW</code>的函数.</p>\n<p>  但是, C 和 C++的函数命名是不同的, 我指的是编译后的函数名字</p>\n<p>  对于 C, 函数<code>int func(int n)</code>会被编译为类似<code>_func</code>这样的名字.</p>\n<p>  对于 C++, 函数<code>int func(int n)</code>会被编译为类似<code>?func@@YAHH@Z</code>这样的名字.</p>\n<p>  同样是 C++, 函数<code>int func(int double)</code>会被编译为类似<code>?func@@YAHN@Z</code>这样的名字(和上一个不同).</p>\n<p>  名字中包含了较多信息, 比如:</p>\n<blockquote>\n<p>参数的入栈方式<br>返回值的类型<br>参数的类型和数量</p>\n</blockquote>\n<p>  这是因为 C++有<code>函数重载</code>特性, 虽然函数命名是<code>func</code>, 但<code>int func(int n)</code>和<code>int func(int double)</code>完全是两个不同的函数, 编译器通过给它们赋予不同的名字来区分它们.ffi 在 dll 中查找函数名字的时候, <strong>是用 C 风格来查找的</strong>.</p>\n<ul>\n<li>  所以,如果你的函数使用 C++编译的, ffl 在这个 dll 中就找不到这个函数, 会出现错误<code>LINK 126</code>!</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>创建工程</p>\n<p> 使用 VS 创建一个 C++ <strong>空项目</strong>即可. 项目名成以 myDLL 为例（当然, 你也可以直接创建动态链接库 DLL）:</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/02.png\" alt=\"02\"></p>\n</li>\n<li><p>函数声明<br> 创建一个 myAdd.h 头文件，并声明一个<code>funAdd</code>函数：</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __declspec(dllexport) <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">funAdd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <code>extern &quot;C&quot;</code>的含义:</p>\n<blockquote>\n<p>被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的</p>\n</blockquote>\n<p> <code>__declspec(dllexport)</code>的含义:</p>\n<blockquote>\n<p>__declspec(dllexport)用于 Windows 中的动态库中，声明导出函数、类、对象等供外面调用，省略给出.def 文件。即将函数、类等声明为导出函数，供其它程序调用，作为动态库的对外接口函数、类等。</p>\n</blockquote>\n</li>\n<li><p>函数定义</p>\n<p> 创建一个 myAdd.cpp 源文件，定义一个<code>funAdd</code>函数：</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;myAdd.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">funAdd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (a + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 创建完 myAdd.h 和 myAdd.cpp 如下图所示：</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/04.png\" alt=\"04\"></p>\n</li>\n<li><p>修改配置类型为动态库.dll<br> 在项目配置中, 选择生成动态库.dll(确保你配置了 Debug 和 Release, 同时确保你在 x64 环境下生成):</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/03.png\" alt=\"03\"></p>\n</li>\n<li><p>生成 dll<br> 右键项目选择生成即可, 生成的 myDLL.dll 位于项目目录下的 x64/Debug 中(根据你项目的配置去找, x64 或 x86, Debug 或 Release)。</p>\n</li>\n<li><p>测试 dll<br> 将 myDLL.dll 拷贝至你的 electron 项目的根目录下的 dll 文件夹内<br> 在<code>main.js</code>中添加如下代码:</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ffi = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ffi-napi&quot;</span>); <span class=\"comment\">// 如果前面已经定义过ffi, 就注释掉这一行</span></span><br><span class=\"line\"><span class=\"comment\">// myDLL.dll</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myDLL = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&quot;/myDLL&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明这个dll中的一个函数</span></span><br><span class=\"line\">    <span class=\"attr\">funAdd</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;int&quot;</span>,</span><br><span class=\"line\">        [<span class=\"string\">&quot;int&quot;</span>, <span class=\"string\">&quot;int&quot;</span>], <span class=\"comment\">// 用json的格式罗列其返回类型和参数类型</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用函数, 参数1和2, 将返回值直接打印出来, 预计为3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = myDLL.<span class=\"title function_\">funAdd</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`the result of 1 + 2 is: `</span> + result);</span><br></pre></td></tr></table></figure>\n\n<p> 启动程序：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn start</span><br></pre></td></tr></table></figure>\n\n<p> 启动成功！shell 里打印出了相应的结果：</p>\n<p> <img src=\"/JohnChu.github.io/2022/03/09/electron02-%E8%B0%83%E7%94%A8DLL/05.png\" alt=\"05\"></p>\n</li>\n</ol>\n<ul>\n<li><p>上面代码中，<code>ffi.Library</code>里第二个参数是一个 Json 结构，key 为方法名，value 为一个数组，数组的第一个参数是<strong>返回值类型</strong>，第二个参数是包含所有<strong>传参类型</strong>的子数组，如：如果返回值是空的话，那数组第一个参数应该是 void。如果返回值或者参数类型不知道是什么类型就写 void*。要使用 ffi 中的类型表示 C/C++语言中的类型，对照表如下：</p>\n<blockquote>\n<p>基本类型<br>int8–Signed 8-bit Integer<br>uint8–Unsigned 8-bit Integer<br>int16–Signed 16-bit Integer<br>uint16–Unsigned 16-bit Integer<br>int32–Signed 32-bit Integer<br>uint32–Unsigned 32-bit Integer<br>int64–Signed 64-bit Integer<br>uint64–Unsigned 64-bit Integer<br>float–Single Precision Floating Point Number (float)<br>double–Double Precision Floating Point Number (double)<br>pointer–Pointer Type<br>string–Null-Terminated String (char *)<br>常见的 C 语言类型<br>byte–unsigned char<br>char–char<br>uchar–unsigned char<br>short–short<br>ushort–unsigned short<br>int–int<br>uint–unsigned int<br>long–long<br>ulong–unsigned long<br>longlong–long<br>ulonglong–unsigned long long<br>size_t–platform-dependent, usually pointer size</p>\n</blockquote>\n<p>  如果是指针类型，可以引入<code>ref-napi</code>和<code>ref-array</code>模块来表示</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> refArray = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-array&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> intPtr = ref.<span class=\"title function_\">refType</span>(<span class=\"string\">&quot;int&quot;</span>); <span class=\"comment\">//int*类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> charPtr = <span class=\"string\">&quot;hello&quot;</span>; <span class=\"comment\">//char*可以用string表示</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果是个字符数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> refArray = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-array&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> charPtrPtr = <span class=\"title function_\">refArray</span>(ref.<span class=\"property\">types</span>.<span class=\"property\">char</span>, <span class=\"number\">50</span>); <span class=\"comment\">//50个大小的数组</span></span><br></pre></td></tr></table></figure>\n\n<p>  假如参数或者返回值是一个结构体，那就需要借助<code>ref-struct</code>模块来表示</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"variable constant_\">FFI</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ffi-napi&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Struct</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;ref-struct&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">TimeVal</span> = <span class=\"title class_\">Struct</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">tv_sec</span>: <span class=\"string\">&quot;long&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">tv_usec</span>: <span class=\"string\">&quot;long&quot;</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">TimeValPtr</span> = ref.<span class=\"title function_\">refType</span>(<span class=\"title class_\">TimeVal</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"keyword\">new</span> <span class=\"variable constant_\">FFI</span>.<span class=\"title class_\">Library</span>(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">gettimeofday</span>: [<span class=\"string\">&quot;int&quot;</span>, [<span class=\"title class_\">TimeValPtr</span>, <span class=\"string\">&quot;pointer&quot;</span>]],</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tv = <span class=\"keyword\">new</span> <span class=\"title class_\">TimeVal</span>();</span><br><span class=\"line\">lib.<span class=\"title function_\">gettimeofday</span>(tv.<span class=\"title function_\">ref</span>(), <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Seconds since epoch: &quot;</span> + tv.<span class=\"property\">tv_sec</span>);</span><br></pre></td></tr></table></figure>\n\n<p>  <strong>注：更多 ref 插件的方法详见 ref 文档： <a href=\"https://tootallnate.github.io/ref/\">https://tootallnate.github.io/ref/</a></strong></p>\n<h2 id=\"可能出现的错误\"><a href=\"#可能出现的错误\" class=\"headerlink\" title=\"可能出现的错误\"></a>可能出现的错误</h2><blockquote>\n<p>错误 1：LINK 126</p>\n</blockquote>\n<p>  这个错误, 意味者 electron 无法使用你的 dll.</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myDLL = <span class=\"keyword\">new</span> ffi.<span class=\"title class_\">Library</span>(<span class=\"string\">&#x27;/myDLL&#x27;</span>, &#123;</span><br></pre></td></tr></table></figure>\n\n<p>  在上面这行代码中，<code>ffi.Library</code>的第一个参数, 不光指定了 dll 的名字, 还指定了 dll 的路径.<br>  出现 LINK 126 有两个常见原因:</p>\n<ol>\n<li>没有这个<strong>目录</strong>, 或这个目录下没有 <code>myDLL.dll</code></li>\n<li><code>myDLL.dll</code> 还<strong>依赖了其他</strong>的一些 dll, 但是 electron 无法找到这个 dll.</li>\n</ol>\n<blockquote>\n<p>错误 2：LINK 127</p>\n</blockquote>\n<p>  出现 LINK 127 的可能原因:</p>\n<ol>\n<li>electron 找到了你的 dll, 但是在 dll 中<strong>找不到</strong>你声名的函数(funAdd)。这通常是由于<strong>函数名字错误</strong>, 或者是<strong>返回值类型</strong>/<strong>参数的个数</strong>及<strong>类型</strong>不一致导致的.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ol>\n<li><a href=\"https://www.cnblogs.com/silenzio/p/11606389.html\">https://www.cnblogs.com/silenzio/p/11606389.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019402908?utm_source=tag-newest\">https://segmentfault.com/a/1190000019402908?utm_source=tag-newest</a></li>\n</ol>\n"},{"title":"first post from john","date":"2022-02-17T13:50:28.000Z","_content":"\n# hello there， i'm john!\n","source":"_posts/first-post-from-john.md","raw":"---\ntitle: first post from john\ndate: 2022-02-17 21:50:28\ntags:\n---\n\n# hello there， i'm john!\n","slug":"first-post-from-john","published":1,"updated":"2022-03-08T05:59:14.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1g7jc1m000288tc4mhv2ap4","content":"<h1 id=\"hello-there，-i’m-john\"><a href=\"#hello-there，-i’m-john\" class=\"headerlink\" title=\"hello there， i’m john!\"></a>hello there， i’m john!</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hello-there，-i’m-john\"><a href=\"#hello-there，-i’m-john\" class=\"headerlink\" title=\"hello there， i’m john!\"></a>hello there， i’m john!</h1>"},{"title":"部署项目到服务器操作流程","date":"2022-03-22T03:33:58.000Z","_content":"\n# 部署项目到服务器操作流程\n\n## 引言\n\n本文将介绍如何将本地的项目部署到服务器上\n\n## 下载 File Zilla Client\n\n下载并安装 file zilla client（下载地址：https://filezilla-project.org）。\n\n## 连接服务器\n\n如图一所示，在 file zilla 中分别输入主机名、用户名、密码、端口，然后点击快速连接接入服务器，出现的弹窗全部点确定。\n\n![图一.上传dist](01.png)\n\n## 将打包的项目上传服务器\n\n先将本地的项目打包生成 dist 文件夹，然后分别找到服务器和本地存放 dist 文件夹的地方，最后右击本地的 dist 文件夹上传到服务器，上传完成后进入下一步。\n\n## 重启服务器服务\n\n如图二所示，打开 shell，执行下面的命令，然后输入密码，cd 到 nginx 服务所在目录，执行 reload 重启服务，完成部署。\n\n![图二.重启服务](02.png)\n","source":"_posts/部署项目到服务器操作流程.md","raw":"---\ntitle: 部署项目到服务器操作流程\ndate: 2022-03-22 11:33:58\ntags:\n---\n\n# 部署项目到服务器操作流程\n\n## 引言\n\n本文将介绍如何将本地的项目部署到服务器上\n\n## 下载 File Zilla Client\n\n下载并安装 file zilla client（下载地址：https://filezilla-project.org）。\n\n## 连接服务器\n\n如图一所示，在 file zilla 中分别输入主机名、用户名、密码、端口，然后点击快速连接接入服务器，出现的弹窗全部点确定。\n\n![图一.上传dist](01.png)\n\n## 将打包的项目上传服务器\n\n先将本地的项目打包生成 dist 文件夹，然后分别找到服务器和本地存放 dist 文件夹的地方，最后右击本地的 dist 文件夹上传到服务器，上传完成后进入下一步。\n\n## 重启服务器服务\n\n如图二所示，打开 shell，执行下面的命令，然后输入密码，cd 到 nginx 服务所在目录，执行 reload 重启服务，完成部署。\n\n![图二.重启服务](02.png)\n","slug":"部署项目到服务器操作流程","published":1,"updated":"2022-03-22T06:21:13.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1g7jc1p000388tc0o55h57l","content":"<h1 id=\"部署项目到服务器操作流程\"><a href=\"#部署项目到服务器操作流程\" class=\"headerlink\" title=\"部署项目到服务器操作流程\"></a>部署项目到服务器操作流程</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>本文将介绍如何将本地的项目部署到服务器上</p>\n<h2 id=\"下载-File-Zilla-Client\"><a href=\"#下载-File-Zilla-Client\" class=\"headerlink\" title=\"下载 File Zilla Client\"></a>下载 File Zilla Client</h2><p>下载并安装 file zilla client（下载地址：<a href=\"https://filezilla-project.org)./\">https://filezilla-project.org）。</a></p>\n<h2 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h2><p>如图一所示，在 file zilla 中分别输入主机名、用户名、密码、端口，然后点击快速连接接入服务器，出现的弹窗全部点确定。</p>\n<p><img src=\"/JohnChu.github.io/2022/03/22/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/01.png\" alt=\"图一.上传dist\"></p>\n<h2 id=\"将打包的项目上传服务器\"><a href=\"#将打包的项目上传服务器\" class=\"headerlink\" title=\"将打包的项目上传服务器\"></a>将打包的项目上传服务器</h2><p>先将本地的项目打包生成 dist 文件夹，然后分别找到服务器和本地存放 dist 文件夹的地方，最后右击本地的 dist 文件夹上传到服务器，上传完成后进入下一步。</p>\n<h2 id=\"重启服务器服务\"><a href=\"#重启服务器服务\" class=\"headerlink\" title=\"重启服务器服务\"></a>重启服务器服务</h2><p>如图二所示，打开 shell，执行下面的命令，然后输入密码，cd 到 nginx 服务所在目录，执行 reload 重启服务，完成部署。</p>\n<p><img src=\"/JohnChu.github.io/2022/03/22/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/02.png\" alt=\"图二.重启服务\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"部署项目到服务器操作流程\"><a href=\"#部署项目到服务器操作流程\" class=\"headerlink\" title=\"部署项目到服务器操作流程\"></a>部署项目到服务器操作流程</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>本文将介绍如何将本地的项目部署到服务器上</p>\n<h2 id=\"下载-File-Zilla-Client\"><a href=\"#下载-File-Zilla-Client\" class=\"headerlink\" title=\"下载 File Zilla Client\"></a>下载 File Zilla Client</h2><p>下载并安装 file zilla client（下载地址：<a href=\"https://filezilla-project.org)./\">https://filezilla-project.org）。</a></p>\n<h2 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h2><p>如图一所示，在 file zilla 中分别输入主机名、用户名、密码、端口，然后点击快速连接接入服务器，出现的弹窗全部点确定。</p>\n<p><img src=\"/JohnChu.github.io/2022/03/22/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/01.png\" alt=\"图一.上传dist\"></p>\n<h2 id=\"将打包的项目上传服务器\"><a href=\"#将打包的项目上传服务器\" class=\"headerlink\" title=\"将打包的项目上传服务器\"></a>将打包的项目上传服务器</h2><p>先将本地的项目打包生成 dist 文件夹，然后分别找到服务器和本地存放 dist 文件夹的地方，最后右击本地的 dist 文件夹上传到服务器，上传完成后进入下一步。</p>\n<h2 id=\"重启服务器服务\"><a href=\"#重启服务器服务\" class=\"headerlink\" title=\"重启服务器服务\"></a>重启服务器服务</h2><p>如图二所示，打开 shell，执行下面的命令，然后输入密码，cd 到 nginx 服务所在目录，执行 reload 重启服务，完成部署。</p>\n<p><img src=\"/JohnChu.github.io/2022/03/22/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/02.png\" alt=\"图二.重启服务\"></p>\n"},{"title":"An introduction to HTML-CSS-JS","date":"2022-04-01T01:45:42.000Z","_content":"\n## 引言\n\n**Web 前端技术由 html、css 和 javascript 三大部分构成，是一个庞大而复杂的技术体系，其复杂程度不低于任何一门后端语言。** 本文从一个小项目入手，由浅至深，逐步介绍前端系统的一些基础知识，旨在帮助初学前端的小伙伴快速地形成一些基础概念。\n\n## 新建项目\n\n-   打开 shell，使用命令新建项目文件夹：\n\n```shell\nmkdir html-css-js //新建项目文件夹，命名html-css-js\ncd html-css-js //进入项目\n```\n\n-   使用 npm 初始化项目：\n\n```shell\nnpm init //初始化项目，之后进行简单配置，回车跳过或使用默认值\n\npackage name: html-css-js                   //项目名称\nversion:   (1.0.0)                          //版本号\ndescription: a introduce to html-css-js     //项目描述\nentry point: (index.js)                     //项目入口文件\ntest command:                               //执行命令\ngit repository:                             //git仓库地址\nkeywords：                                  //项目关键字\nauthor: john                                //作者名字\nlicense:                                    //发行项目证书\n```\n\n下面分别新建 html、css、js 三个文件，它们三者这件的关系可以用下图进行类比：\n![01](metaphor.png)\n\n-   使用编辑器打开该项目文件夹，然后新建一个 html 文件（命名 index.html），作为页面的骨架\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n        <link\n            rel=\"stylesheet\"\n            href=\"https://www.w3schools.com/w3css/4/w3.css\"\n        />\n    </head>\n    <body>\n        <div class=\"hello\">\n            hello world!\n            <div id=\"cue\">点我变大</div>\n        </div>\n    </body>\n</html>\n```\n\n-   新建 css 文件，用来控制 html 中的样式\n\n```css\n.hello {\n    cursor: pointer;\n    font-size: 50px;\n    text-align: center;\n    color: aquamarine;\n}\n```\n\n-   新建 js，实现一些页面操作和功能\n\n```js\nlet hello = document.querySelector(\".hello\");\nhello.addEventListener(\"click\", function () {\n    changeSize(hello);\n});\n\nfunction changeSize(obj) {\n    let style = window.getComputedStyle(obj, null);\n    let cue = document.getElementById(\"cue\");\n    if (style.fontSize === \"50px\") {\n        obj.style = \"font-size:100px\";\n        cue.innerHTML = \"点我变小\";\n    } else {\n        obj.style = \"font-size:50px\";\n        cue.innerHTML = \"点我变大\";\n    }\n}\n```\n\n**我们还需要一些额外的中间件将项目运行起来**\n首先，安装 express 来启动服务：\n\n```shell\nnpm i express --save\n```\n\n然后，新建 app.js 作为启动文件\n\n```js\nvar express = require(\"express\");\nvar path = require(\"path\");\n\nvar app = express();\n\napp.use(express.static(path.join(__dirname, \"\")));\n\nvar server = app.listen(8081, \"127.0.0.1\", function () {\n    var host = server.address().address;\n    var port = server.address().port;\n\n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);\n});\n```\n\n其中最主要的部分是 app.use(express.static(path.join(\\_\\_dirname, ''))) ，该行代码是在 express 添加中间件，设置静态资源路径为根目录，所有的 HTML、CSS、JS 等文件都放在**根目录**下即可\n\n最后，使用 node 运行\n\n```shell\nnode app.js //项目最终运行在127.0.0.1:8081\n```\n\n## HTML 知识点\n\n### 1、BOM\n\nBOM 是 Browser Object Model 的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即 BOM。BOM 的核心对象就是 window，window 对象也是 BOM 的顶级对象，其中包含了浏览器的 6 个核心模块：\n\n-   document -即文档对象，渲染引擎在解析 HTML 代码时，会为每一个元素生成对应的 DOM 对象，由于元素之间有层级关系，因此整个 HTML 代码解析完以后，会生成一个由不同节点组成的树形结构，俗称 DOM 树，document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。\n\n-   frames - HTML 子框架，即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。\n\n-   history - 以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。\n\n-   location - 提供了当前窗口中加载的文档相关信息以及一些导航功能。\n\n-   navigator - 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。\n\n-   screen - 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。\n\n### 2、DOM 系统\n\nDOM 是 Document Object Model 的缩写，即 文档对象模型，是所有浏览器公共遵守的标准，DOM 将 HTML 和 XML 文档映射成一个由不同节点组成的树型结构，俗称 DOM 树。其核心对象是 document，用于描述 DOM 树的状态和属性，并提供对应的 DOM 操作 API。随着历史的发展，DOM 被划分为 1 级、2 级、3 级，共 3 个级别：\n\n-   1 级 DOM - 在 1998 年 10 月份成为 W3C 的提议，由 DOM 核心与 DOM HTML 两个模块组成。DOM 核心能映射以 XML 为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML 通过添加 HTML 专用的对象与函数对 DOM 核心进行了扩展。\n\n-   2 级 DOM - 鉴于 1 级 DOM 仅以映射文档结构为目标，DOM 2 级面向更为宽广。通过对原有 DOM 的扩展，2 级 DOM 通过对象接口增加了对鼠标和用户界面事件(DHTML 长期支持鼠标与用户界面事件)、范围、遍历(重复执行 DOM 文档)和层叠样式表(CSS)的支持。同时也对 DOM 1 的核心进行了扩展，从而可支持 XML 命名空间。\n\n-   3 级 DOM -通过引入统一方式载入和保存文档和文档验证方法对 DOM 进行进一步扩展，DOM3 包含一个名为“DOM 载入与保存”的新模块，DOM 核心扩展后可支持 XML1.0 的所有内容，包括 XMLInfoset、 XPath、和 XML Base。\n\n![02](DOM.png)\n\n从图中可以看出，移动端常用的 webkit 内核浏览器目前只支持 DOM2，而不支持 DOM3 。\n\n### 3、事件系统\n\n事件是用户与页面交互的基础，到目前为止，DOM 事件从 PC 端的 鼠标事件(mouse) 发展到了 移动端的 触摸事件(touch) 和手势事件(guesture)，touch 事件描述了手指在屏幕操作的每一个细节，guesture 则是描述多手指操作时更为复杂的情况。\n\nDOM2.0 模型将事件处理流程分为三个阶段，即 事件捕获阶段 、 事件处理阶段 、 事件冒泡阶段， 如图所示：\n\n-   事件捕获 ：当用户触发点击事件后，顶层对象 document 就会发出一个事件流，从最外层的 DOM 节点向目标元素节点传递，最终到达目标元素。\n\n-   事件处理 ：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。\n\n-   事件冒泡 ：事件流从目标元素开始，向最外层 DOM 节点传递，途中如果有节点绑定了事件处理函数，这些函数就会被执行。\n\n利用事件冒泡原理可以实现 事件委托，所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素再通过 event.target 获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。\n\n### 4、HTML 解析过程\n\n渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程：\n![03](render.png)\n\n-   HTML Parser 解析 HTML 文档，并将各标记逐个转化为 DOM 节点，生成 **DOM 树**。\n-   CSS Parser 解析外部 CSS 文件以及样式元素中的样式数据，生成 **CSSOM 树**。\n-   **DOM 树** 和 **CSSOM 树** 通过 “附着” 将创建另一个树结构：**渲染树**。\n-   **渲染树** 包含多个带有视觉属性（如颜色和尺寸）的矩形，这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n-   渲染树构建完毕之后，进入 **布局** 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。\n-   下一个阶段是 **绘制**，渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。\n\n需要注意的是：\n\n> 这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n## CSS 知识点\n\n### 1、CSS 选择器\n\nCSS 选择器即通过某种规则来匹配相应的标签，并为其设置 CSS 样式，常用的有：\n\n-   类选择器(.a)\n-   标签选择器(div)\n-   ID 选择器(#a)\n-   后代选择器(h1 .a)\n-   子元素选择器(h1 > a)\n-   群组选择器(h1,h2,h3)\n-   伪类选择器(::before/::after)\n-   相邻兄弟选择器(h1 + p)\n-   属性选择器(a[href][title])\n\n### 2、CSS Reset\n\nHTML 标签在不设置任何样式的情况下，也会有一个默认的 CSS 样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是 CSSReset ，即 CSS 样式重置，比如：\\*{margin:0,padding:0} 就是最简单 CSS Reset。\n\n### 3、盒子布局\n\n盒子模型是 CSS 比较重要的一个概念，也是 CSS 布局的基石。\n\n常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding 和 content 等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing 属性的设置会影响盒子 width 和 height 的计算。\n\n### 4、浮动布局\n\n设置元素的 float 属性值为 left 或 right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear:both，更高级一点的就给父容器设置 before/after 来模拟一个空元素，还可以直接设置 overflow 属性为 auto/hidden 来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block)和 table 也可以实现同样的效果。\n\n### 5、定位布局\n\n设置元素的 position 属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，releave 是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用;absolute 是绝对定位，它以离自己最近的定位父容器作为参照进行偏移;为了对某个元素进行定位，常用的方式就是设置父容器的 poistion:relative，因为相对定位元素在不设置 top 和 left 值时，不会对元素位置产生影响;fixed 即固定定位，它则以浏览器窗口为参照物，PC 网页底部悬停的 banner 一般都可以通过 fixed 定位来实现，但 fixed 属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。\n\n### 6、弹性布局\n\n弹性布局即 Flex 布局，定义了 flex 的容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小;然后当 Flex 容器被应用一个大小时(width 和 height)，将会自动调整容器中的元素适应新大小。Flex 容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向(横向和纵向)和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。\n\n## JS 知识点\n\n### 1、基础语法\n\nJavaScript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。\n\n-   在 ES5 中，变量声明有两种方式，分别是 var 和 function ，var 用于声明普通的变量，接收任意类型，function 用于声明函数。另外，ES6 新增了 let、const、import 和 class 等四个命令，分别用以声明 普通变量、静态变量、模块 和 类 。\n\n-   JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了 Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(Primitive Type)。\n\n-   原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中(按值访问)。为了便于操作这类数据，ECMAScript 提供了 3 个 基本包装类型 ：Boolean、Number 和 String。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS 内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据。\n\n引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法;但基本类型不可以添加属性和方法。\n\nJavaScript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的 toString 方法来判断。\n\nJS 中的函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过 new 创建对象时就是构造函数，通过对象调用时就是方法。\n\n-   JS 常用的内置对象有 window、Date、Array、JSON、RegExp 等，window 是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关的属性和状态，这个后面会讲到，Date 和 Array 使用场景最多，JSON 主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。\n\n### 2、函数原型链\n\nJS 是一种基于对象的语言，但在 ES6 之前是不支持继承的，为了具备继承的能力，JavaScript 在 函数对象上建立了原型对象 prototype，并以函数对象为主线，从上至下，在 JS 内部构建了一条 原型链 。原型链把一个个独立的对象联系在一起，Object 则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了 Object，并以 Object 终结。\n\n简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到 Object 对象为止，如果都没有找到该属性才会返回 undefined。因此，我们可以通过原型链来实现 JS 继承。\n\n### 3、函数作用域\n\n函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。因此， JS 中没有块级作用域，只有函数作用域，这种设计导致 JS 中出现了 变量提升 的问题。简单来说就是，将变量声明提升到它所在作用域的最开始的部分，为了解决变量提升带来的副作用，ES6 新增了 let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题。\n\n### 4、this 指针\n\nthis 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this 指向规则也不一样：对于普通函数，this 始终指向全局对象 window;对于构造函数，this 则指向新创建的对象;对于方法，this 指向调用该方法的对象。另外，Function 对象也提供了 call、apply 和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind 一般在事件回调中使用，而 call 和 apply 的区别只是参数的传递方式不同。\n\n如果往深的去理解，无论什么函数，this 是否被改变， 本质上，this 均指向触发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。\n\n### 5、new 操作符\n\n函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()。前面提到，JS 中的函数即可以是函数，也可以是方法，还可以是构造函数。当使用 new 来创建对象时，该函数就是构造函数，JS 将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型 prototype 中的方法和属性。\n\n## Reference\n\nhttps://www.cnblogs.com/onepixel/p/7021506.html\n","source":"_posts/An-introduction-to-HTML-CSS-JS.md","raw":"---\ntitle: An introduction to HTML-CSS-JS\ndate: 2022-04-01 09:45:42\ntags:\n---\n\n## 引言\n\n**Web 前端技术由 html、css 和 javascript 三大部分构成，是一个庞大而复杂的技术体系，其复杂程度不低于任何一门后端语言。** 本文从一个小项目入手，由浅至深，逐步介绍前端系统的一些基础知识，旨在帮助初学前端的小伙伴快速地形成一些基础概念。\n\n## 新建项目\n\n-   打开 shell，使用命令新建项目文件夹：\n\n```shell\nmkdir html-css-js //新建项目文件夹，命名html-css-js\ncd html-css-js //进入项目\n```\n\n-   使用 npm 初始化项目：\n\n```shell\nnpm init //初始化项目，之后进行简单配置，回车跳过或使用默认值\n\npackage name: html-css-js                   //项目名称\nversion:   (1.0.0)                          //版本号\ndescription: a introduce to html-css-js     //项目描述\nentry point: (index.js)                     //项目入口文件\ntest command:                               //执行命令\ngit repository:                             //git仓库地址\nkeywords：                                  //项目关键字\nauthor: john                                //作者名字\nlicense:                                    //发行项目证书\n```\n\n下面分别新建 html、css、js 三个文件，它们三者这件的关系可以用下图进行类比：\n![01](metaphor.png)\n\n-   使用编辑器打开该项目文件夹，然后新建一个 html 文件（命名 index.html），作为页面的骨架\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n        <link\n            rel=\"stylesheet\"\n            href=\"https://www.w3schools.com/w3css/4/w3.css\"\n        />\n    </head>\n    <body>\n        <div class=\"hello\">\n            hello world!\n            <div id=\"cue\">点我变大</div>\n        </div>\n    </body>\n</html>\n```\n\n-   新建 css 文件，用来控制 html 中的样式\n\n```css\n.hello {\n    cursor: pointer;\n    font-size: 50px;\n    text-align: center;\n    color: aquamarine;\n}\n```\n\n-   新建 js，实现一些页面操作和功能\n\n```js\nlet hello = document.querySelector(\".hello\");\nhello.addEventListener(\"click\", function () {\n    changeSize(hello);\n});\n\nfunction changeSize(obj) {\n    let style = window.getComputedStyle(obj, null);\n    let cue = document.getElementById(\"cue\");\n    if (style.fontSize === \"50px\") {\n        obj.style = \"font-size:100px\";\n        cue.innerHTML = \"点我变小\";\n    } else {\n        obj.style = \"font-size:50px\";\n        cue.innerHTML = \"点我变大\";\n    }\n}\n```\n\n**我们还需要一些额外的中间件将项目运行起来**\n首先，安装 express 来启动服务：\n\n```shell\nnpm i express --save\n```\n\n然后，新建 app.js 作为启动文件\n\n```js\nvar express = require(\"express\");\nvar path = require(\"path\");\n\nvar app = express();\n\napp.use(express.static(path.join(__dirname, \"\")));\n\nvar server = app.listen(8081, \"127.0.0.1\", function () {\n    var host = server.address().address;\n    var port = server.address().port;\n\n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);\n});\n```\n\n其中最主要的部分是 app.use(express.static(path.join(\\_\\_dirname, ''))) ，该行代码是在 express 添加中间件，设置静态资源路径为根目录，所有的 HTML、CSS、JS 等文件都放在**根目录**下即可\n\n最后，使用 node 运行\n\n```shell\nnode app.js //项目最终运行在127.0.0.1:8081\n```\n\n## HTML 知识点\n\n### 1、BOM\n\nBOM 是 Browser Object Model 的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即 BOM。BOM 的核心对象就是 window，window 对象也是 BOM 的顶级对象，其中包含了浏览器的 6 个核心模块：\n\n-   document -即文档对象，渲染引擎在解析 HTML 代码时，会为每一个元素生成对应的 DOM 对象，由于元素之间有层级关系，因此整个 HTML 代码解析完以后，会生成一个由不同节点组成的树形结构，俗称 DOM 树，document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。\n\n-   frames - HTML 子框架，即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。\n\n-   history - 以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。\n\n-   location - 提供了当前窗口中加载的文档相关信息以及一些导航功能。\n\n-   navigator - 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。\n\n-   screen - 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。\n\n### 2、DOM 系统\n\nDOM 是 Document Object Model 的缩写，即 文档对象模型，是所有浏览器公共遵守的标准，DOM 将 HTML 和 XML 文档映射成一个由不同节点组成的树型结构，俗称 DOM 树。其核心对象是 document，用于描述 DOM 树的状态和属性，并提供对应的 DOM 操作 API。随着历史的发展，DOM 被划分为 1 级、2 级、3 级，共 3 个级别：\n\n-   1 级 DOM - 在 1998 年 10 月份成为 W3C 的提议，由 DOM 核心与 DOM HTML 两个模块组成。DOM 核心能映射以 XML 为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML 通过添加 HTML 专用的对象与函数对 DOM 核心进行了扩展。\n\n-   2 级 DOM - 鉴于 1 级 DOM 仅以映射文档结构为目标，DOM 2 级面向更为宽广。通过对原有 DOM 的扩展，2 级 DOM 通过对象接口增加了对鼠标和用户界面事件(DHTML 长期支持鼠标与用户界面事件)、范围、遍历(重复执行 DOM 文档)和层叠样式表(CSS)的支持。同时也对 DOM 1 的核心进行了扩展，从而可支持 XML 命名空间。\n\n-   3 级 DOM -通过引入统一方式载入和保存文档和文档验证方法对 DOM 进行进一步扩展，DOM3 包含一个名为“DOM 载入与保存”的新模块，DOM 核心扩展后可支持 XML1.0 的所有内容，包括 XMLInfoset、 XPath、和 XML Base。\n\n![02](DOM.png)\n\n从图中可以看出，移动端常用的 webkit 内核浏览器目前只支持 DOM2，而不支持 DOM3 。\n\n### 3、事件系统\n\n事件是用户与页面交互的基础，到目前为止，DOM 事件从 PC 端的 鼠标事件(mouse) 发展到了 移动端的 触摸事件(touch) 和手势事件(guesture)，touch 事件描述了手指在屏幕操作的每一个细节，guesture 则是描述多手指操作时更为复杂的情况。\n\nDOM2.0 模型将事件处理流程分为三个阶段，即 事件捕获阶段 、 事件处理阶段 、 事件冒泡阶段， 如图所示：\n\n-   事件捕获 ：当用户触发点击事件后，顶层对象 document 就会发出一个事件流，从最外层的 DOM 节点向目标元素节点传递，最终到达目标元素。\n\n-   事件处理 ：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。\n\n-   事件冒泡 ：事件流从目标元素开始，向最外层 DOM 节点传递，途中如果有节点绑定了事件处理函数，这些函数就会被执行。\n\n利用事件冒泡原理可以实现 事件委托，所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素再通过 event.target 获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。\n\n### 4、HTML 解析过程\n\n渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程：\n![03](render.png)\n\n-   HTML Parser 解析 HTML 文档，并将各标记逐个转化为 DOM 节点，生成 **DOM 树**。\n-   CSS Parser 解析外部 CSS 文件以及样式元素中的样式数据，生成 **CSSOM 树**。\n-   **DOM 树** 和 **CSSOM 树** 通过 “附着” 将创建另一个树结构：**渲染树**。\n-   **渲染树** 包含多个带有视觉属性（如颜色和尺寸）的矩形，这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n-   渲染树构建完毕之后，进入 **布局** 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。\n-   下一个阶段是 **绘制**，渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。\n\n需要注意的是：\n\n> 这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n## CSS 知识点\n\n### 1、CSS 选择器\n\nCSS 选择器即通过某种规则来匹配相应的标签，并为其设置 CSS 样式，常用的有：\n\n-   类选择器(.a)\n-   标签选择器(div)\n-   ID 选择器(#a)\n-   后代选择器(h1 .a)\n-   子元素选择器(h1 > a)\n-   群组选择器(h1,h2,h3)\n-   伪类选择器(::before/::after)\n-   相邻兄弟选择器(h1 + p)\n-   属性选择器(a[href][title])\n\n### 2、CSS Reset\n\nHTML 标签在不设置任何样式的情况下，也会有一个默认的 CSS 样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是 CSSReset ，即 CSS 样式重置，比如：\\*{margin:0,padding:0} 就是最简单 CSS Reset。\n\n### 3、盒子布局\n\n盒子模型是 CSS 比较重要的一个概念，也是 CSS 布局的基石。\n\n常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding 和 content 等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing 属性的设置会影响盒子 width 和 height 的计算。\n\n### 4、浮动布局\n\n设置元素的 float 属性值为 left 或 right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear:both，更高级一点的就给父容器设置 before/after 来模拟一个空元素，还可以直接设置 overflow 属性为 auto/hidden 来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block)和 table 也可以实现同样的效果。\n\n### 5、定位布局\n\n设置元素的 position 属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，releave 是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用;absolute 是绝对定位，它以离自己最近的定位父容器作为参照进行偏移;为了对某个元素进行定位，常用的方式就是设置父容器的 poistion:relative，因为相对定位元素在不设置 top 和 left 值时，不会对元素位置产生影响;fixed 即固定定位，它则以浏览器窗口为参照物，PC 网页底部悬停的 banner 一般都可以通过 fixed 定位来实现，但 fixed 属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。\n\n### 6、弹性布局\n\n弹性布局即 Flex 布局，定义了 flex 的容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小;然后当 Flex 容器被应用一个大小时(width 和 height)，将会自动调整容器中的元素适应新大小。Flex 容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向(横向和纵向)和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。\n\n## JS 知识点\n\n### 1、基础语法\n\nJavaScript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。\n\n-   在 ES5 中，变量声明有两种方式，分别是 var 和 function ，var 用于声明普通的变量，接收任意类型，function 用于声明函数。另外，ES6 新增了 let、const、import 和 class 等四个命令，分别用以声明 普通变量、静态变量、模块 和 类 。\n\n-   JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了 Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(Primitive Type)。\n\n-   原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中(按值访问)。为了便于操作这类数据，ECMAScript 提供了 3 个 基本包装类型 ：Boolean、Number 和 String。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS 内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据。\n\n引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法;但基本类型不可以添加属性和方法。\n\nJavaScript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的 toString 方法来判断。\n\nJS 中的函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过 new 创建对象时就是构造函数，通过对象调用时就是方法。\n\n-   JS 常用的内置对象有 window、Date、Array、JSON、RegExp 等，window 是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关的属性和状态，这个后面会讲到，Date 和 Array 使用场景最多，JSON 主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。\n\n### 2、函数原型链\n\nJS 是一种基于对象的语言，但在 ES6 之前是不支持继承的，为了具备继承的能力，JavaScript 在 函数对象上建立了原型对象 prototype，并以函数对象为主线，从上至下，在 JS 内部构建了一条 原型链 。原型链把一个个独立的对象联系在一起，Object 则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了 Object，并以 Object 终结。\n\n简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到 Object 对象为止，如果都没有找到该属性才会返回 undefined。因此，我们可以通过原型链来实现 JS 继承。\n\n### 3、函数作用域\n\n函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。因此， JS 中没有块级作用域，只有函数作用域，这种设计导致 JS 中出现了 变量提升 的问题。简单来说就是，将变量声明提升到它所在作用域的最开始的部分，为了解决变量提升带来的副作用，ES6 新增了 let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题。\n\n### 4、this 指针\n\nthis 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this 指向规则也不一样：对于普通函数，this 始终指向全局对象 window;对于构造函数，this 则指向新创建的对象;对于方法，this 指向调用该方法的对象。另外，Function 对象也提供了 call、apply 和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind 一般在事件回调中使用，而 call 和 apply 的区别只是参数的传递方式不同。\n\n如果往深的去理解，无论什么函数，this 是否被改变， 本质上，this 均指向触发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。\n\n### 5、new 操作符\n\n函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()。前面提到，JS 中的函数即可以是函数，也可以是方法，还可以是构造函数。当使用 new 来创建对象时，该函数就是构造函数，JS 将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型 prototype 中的方法和属性。\n\n## Reference\n\nhttps://www.cnblogs.com/onepixel/p/7021506.html\n","slug":"An-introduction-to-HTML-CSS-JS","published":1,"updated":"2022-04-01T09:12:21.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1g7jc1q000488tc13yj322e","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p><strong>Web 前端技术由 html、css 和 javascript 三大部分构成，是一个庞大而复杂的技术体系，其复杂程度不低于任何一门后端语言。</strong> 本文从一个小项目入手，由浅至深，逐步介绍前端系统的一些基础知识，旨在帮助初学前端的小伙伴快速地形成一些基础概念。</p>\n<h2 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h2><ul>\n<li>  打开 shell，使用命令新建项目文件夹：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir html-css-js //新建项目文件夹，命名html-css-js</span><br><span class=\"line\">cd html-css-js //进入项目</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  使用 npm 初始化项目：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init //初始化项目，之后进行简单配置，回车跳过或使用默认值</span><br><span class=\"line\"></span><br><span class=\"line\">package name: html-css-js                   //项目名称</span><br><span class=\"line\">version:   (1.0.0)                          //版本号</span><br><span class=\"line\">description: a introduce to html-css-js     //项目描述</span><br><span class=\"line\">entry point: (index.js)                     //项目入口文件</span><br><span class=\"line\">test command:                               //执行命令</span><br><span class=\"line\">git repository:                             //git仓库地址</span><br><span class=\"line\">keywords：                                  //项目关键字</span><br><span class=\"line\">author: john                                //作者名字</span><br><span class=\"line\">license:                                    //发行项目证书</span><br></pre></td></tr></table></figure>\n\n<p>下面分别新建 html、css、js 三个文件，它们三者这件的关系可以用下图进行类比：<br><img src=\"/JohnChu.github.io/2022/04/01/An-introduction-to-HTML-CSS-JS/metaphor.png\" alt=\"01\"></p>\n<ul>\n<li>  使用编辑器打开该项目文件夹，然后新建一个 html 文件（命名 index.html），作为页面的骨架</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://www.w3schools.com/w3css/4/w3.css&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;hello&quot;</span>&gt;</span></span><br><span class=\"line\">            hello world!</span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cue&quot;</span>&gt;</span>点我变大<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  新建 css 文件，用来控制 html 中的样式</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.hello</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: aquamarine;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  新建 js，实现一些页面操作和功能</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;.hello&quot;</span>);</span><br><span class=\"line\">hello.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">changeSize</span>(hello);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">changeSize</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> style = <span class=\"variable language_\">window</span>.<span class=\"title function_\">getComputedStyle</span>(obj, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cue = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;cue&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (style.<span class=\"property\">fontSize</span> === <span class=\"string\">&quot;50px&quot;</span>) &#123;</span><br><span class=\"line\">        obj.<span class=\"property\">style</span> = <span class=\"string\">&quot;font-size:100px&quot;</span>;</span><br><span class=\"line\">        cue.<span class=\"property\">innerHTML</span> = <span class=\"string\">&quot;点我变小&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.<span class=\"property\">style</span> = <span class=\"string\">&quot;font-size:50px&quot;</span>;</span><br><span class=\"line\">        cue.<span class=\"property\">innerHTML</span> = <span class=\"string\">&quot;点我变大&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们还需要一些额外的中间件将项目运行起来</strong><br>首先，安装 express 来启动服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i express --save</span><br></pre></td></tr></table></figure>\n\n<p>然后，新建 app.js 作为启动文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;express&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;path&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(express.<span class=\"title function_\">static</span>(path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&quot;&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> server = app.<span class=\"title function_\">listen</span>(<span class=\"number\">8081</span>, <span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> host = server.<span class=\"title function_\">address</span>().<span class=\"property\">address</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> port = server.<span class=\"title function_\">address</span>().<span class=\"property\">port</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;应用实例，访问地址为 http://%s:%s&quot;</span>, host, port);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其中最主要的部分是 app.use(express.static(path.join(__dirname, ‘’))) ，该行代码是在 express 添加中间件，设置静态资源路径为根目录，所有的 HTML、CSS、JS 等文件都放在<strong>根目录</strong>下即可</p>\n<p>最后，使用 node 运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node app.js //项目最终运行在127.0.0.1:8081</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML-知识点\"><a href=\"#HTML-知识点\" class=\"headerlink\" title=\"HTML 知识点\"></a>HTML 知识点</h2><h3 id=\"1、BOM\"><a href=\"#1、BOM\" class=\"headerlink\" title=\"1、BOM\"></a>1、BOM</h3><p>BOM 是 Browser Object Model 的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即 BOM。BOM 的核心对象就是 window，window 对象也是 BOM 的顶级对象，其中包含了浏览器的 6 个核心模块：</p>\n<ul>\n<li><p>  document -即文档对象，渲染引擎在解析 HTML 代码时，会为每一个元素生成对应的 DOM 对象，由于元素之间有层级关系，因此整个 HTML 代码解析完以后，会生成一个由不同节点组成的树形结构，俗称 DOM 树，document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。</p>\n</li>\n<li><p>  frames - HTML 子框架，即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。</p>\n</li>\n<li><p>  history - 以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。</p>\n</li>\n<li><p>  location - 提供了当前窗口中加载的文档相关信息以及一些导航功能。</p>\n</li>\n<li><p>  navigator - 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。</p>\n</li>\n<li><p>  screen - 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。</p>\n</li>\n</ul>\n<h3 id=\"2、DOM-系统\"><a href=\"#2、DOM-系统\" class=\"headerlink\" title=\"2、DOM 系统\"></a>2、DOM 系统</h3><p>DOM 是 Document Object Model 的缩写，即 文档对象模型，是所有浏览器公共遵守的标准，DOM 将 HTML 和 XML 文档映射成一个由不同节点组成的树型结构，俗称 DOM 树。其核心对象是 document，用于描述 DOM 树的状态和属性，并提供对应的 DOM 操作 API。随着历史的发展，DOM 被划分为 1 级、2 级、3 级，共 3 个级别：</p>\n<ul>\n<li><p>  1 级 DOM - 在 1998 年 10 月份成为 W3C 的提议，由 DOM 核心与 DOM HTML 两个模块组成。DOM 核心能映射以 XML 为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML 通过添加 HTML 专用的对象与函数对 DOM 核心进行了扩展。</p>\n</li>\n<li><p>  2 级 DOM - 鉴于 1 级 DOM 仅以映射文档结构为目标，DOM 2 级面向更为宽广。通过对原有 DOM 的扩展，2 级 DOM 通过对象接口增加了对鼠标和用户界面事件(DHTML 长期支持鼠标与用户界面事件)、范围、遍历(重复执行 DOM 文档)和层叠样式表(CSS)的支持。同时也对 DOM 1 的核心进行了扩展，从而可支持 XML 命名空间。</p>\n</li>\n<li><p>  3 级 DOM -通过引入统一方式载入和保存文档和文档验证方法对 DOM 进行进一步扩展，DOM3 包含一个名为“DOM 载入与保存”的新模块，DOM 核心扩展后可支持 XML1.0 的所有内容，包括 XMLInfoset、 XPath、和 XML Base。</p>\n</li>\n</ul>\n<p><img src=\"/JohnChu.github.io/2022/04/01/An-introduction-to-HTML-CSS-JS/DOM.png\" alt=\"02\"></p>\n<p>从图中可以看出，移动端常用的 webkit 内核浏览器目前只支持 DOM2，而不支持 DOM3 。</p>\n<h3 id=\"3、事件系统\"><a href=\"#3、事件系统\" class=\"headerlink\" title=\"3、事件系统\"></a>3、事件系统</h3><p>事件是用户与页面交互的基础，到目前为止，DOM 事件从 PC 端的 鼠标事件(mouse) 发展到了 移动端的 触摸事件(touch) 和手势事件(guesture)，touch 事件描述了手指在屏幕操作的每一个细节，guesture 则是描述多手指操作时更为复杂的情况。</p>\n<p>DOM2.0 模型将事件处理流程分为三个阶段，即 事件捕获阶段 、 事件处理阶段 、 事件冒泡阶段， 如图所示：</p>\n<ul>\n<li><p>  事件捕获 ：当用户触发点击事件后，顶层对象 document 就会发出一个事件流，从最外层的 DOM 节点向目标元素节点传递，最终到达目标元素。</p>\n</li>\n<li><p>  事件处理 ：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。</p>\n</li>\n<li><p>  事件冒泡 ：事件流从目标元素开始，向最外层 DOM 节点传递，途中如果有节点绑定了事件处理函数，这些函数就会被执行。</p>\n</li>\n</ul>\n<p>利用事件冒泡原理可以实现 事件委托，所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素再通过 event.target 获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。</p>\n<h3 id=\"4、HTML-解析过程\"><a href=\"#4、HTML-解析过程\" class=\"headerlink\" title=\"4、HTML 解析过程\"></a>4、HTML 解析过程</h3><p>渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程：<br><img src=\"/JohnChu.github.io/2022/04/01/An-introduction-to-HTML-CSS-JS/render.png\" alt=\"03\"></p>\n<ul>\n<li>  HTML Parser 解析 HTML 文档，并将各标记逐个转化为 DOM 节点，生成 <strong>DOM 树</strong>。</li>\n<li>  CSS Parser 解析外部 CSS 文件以及样式元素中的样式数据，生成 <strong>CSSOM 树</strong>。</li>\n<li>  <strong>DOM 树</strong> 和 <strong>CSSOM 树</strong> 通过 “附着” 将创建另一个树结构：<strong>渲染树</strong>。</li>\n<li>  <strong>渲染树</strong> 包含多个带有视觉属性（如颜色和尺寸）的矩形，这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</li>\n<li>  渲染树构建完毕之后，进入 <strong>布局</strong> 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。</li>\n<li>  下一个阶段是 <strong>绘制</strong>，渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。</li>\n</ul>\n<p>需要注意的是：</p>\n<blockquote>\n<p>这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n</blockquote>\n<h2 id=\"CSS-知识点\"><a href=\"#CSS-知识点\" class=\"headerlink\" title=\"CSS 知识点\"></a>CSS 知识点</h2><h3 id=\"1、CSS-选择器\"><a href=\"#1、CSS-选择器\" class=\"headerlink\" title=\"1、CSS 选择器\"></a>1、CSS 选择器</h3><p>CSS 选择器即通过某种规则来匹配相应的标签，并为其设置 CSS 样式，常用的有：</p>\n<ul>\n<li>  类选择器(.a)</li>\n<li>  标签选择器(div)</li>\n<li>  ID 选择器(#a)</li>\n<li>  后代选择器(h1 .a)</li>\n<li>  子元素选择器(h1 &gt; a)</li>\n<li>  群组选择器(h1,h2,h3)</li>\n<li>  伪类选择器(::before/::after)</li>\n<li>  相邻兄弟选择器(h1 + p)</li>\n<li>  属性选择器(a[href][title])</li>\n</ul>\n<h3 id=\"2、CSS-Reset\"><a href=\"#2、CSS-Reset\" class=\"headerlink\" title=\"2、CSS Reset\"></a>2、CSS Reset</h3><p>HTML 标签在不设置任何样式的情况下，也会有一个默认的 CSS 样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是 CSSReset ，即 CSS 样式重置，比如：*{margin:0,padding:0} 就是最简单 CSS Reset。</p>\n<h3 id=\"3、盒子布局\"><a href=\"#3、盒子布局\" class=\"headerlink\" title=\"3、盒子布局\"></a>3、盒子布局</h3><p>盒子模型是 CSS 比较重要的一个概念，也是 CSS 布局的基石。</p>\n<p>常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding 和 content 等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing 属性的设置会影响盒子 width 和 height 的计算。</p>\n<h3 id=\"4、浮动布局\"><a href=\"#4、浮动布局\" class=\"headerlink\" title=\"4、浮动布局\"></a>4、浮动布局</h3><p>设置元素的 float 属性值为 left 或 right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear:both，更高级一点的就给父容器设置 before/after 来模拟一个空元素，还可以直接设置 overflow 属性为 auto/hidden 来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block)和 table 也可以实现同样的效果。</p>\n<h3 id=\"5、定位布局\"><a href=\"#5、定位布局\" class=\"headerlink\" title=\"5、定位布局\"></a>5、定位布局</h3><p>设置元素的 position 属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，releave 是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用;absolute 是绝对定位，它以离自己最近的定位父容器作为参照进行偏移;为了对某个元素进行定位，常用的方式就是设置父容器的 poistion:relative，因为相对定位元素在不设置 top 和 left 值时，不会对元素位置产生影响;fixed 即固定定位，它则以浏览器窗口为参照物，PC 网页底部悬停的 banner 一般都可以通过 fixed 定位来实现，但 fixed 属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。</p>\n<h3 id=\"6、弹性布局\"><a href=\"#6、弹性布局\" class=\"headerlink\" title=\"6、弹性布局\"></a>6、弹性布局</h3><p>弹性布局即 Flex 布局，定义了 flex 的容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小;然后当 Flex 容器被应用一个大小时(width 和 height)，将会自动调整容器中的元素适应新大小。Flex 容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向(横向和纵向)和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>\n<h2 id=\"JS-知识点\"><a href=\"#JS-知识点\" class=\"headerlink\" title=\"JS 知识点\"></a>JS 知识点</h2><h3 id=\"1、基础语法\"><a href=\"#1、基础语法\" class=\"headerlink\" title=\"1、基础语法\"></a>1、基础语法</h3><p>JavaScript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。</p>\n<ul>\n<li><p>  在 ES5 中，变量声明有两种方式，分别是 var 和 function ，var 用于声明普通的变量，接收任意类型，function 用于声明函数。另外，ES6 新增了 let、const、import 和 class 等四个命令，分别用以声明 普通变量、静态变量、模块 和 类 。</p>\n</li>\n<li><p>  JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了 Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(Primitive Type)。</p>\n</li>\n<li><p>  原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中(按值访问)。为了便于操作这类数据，ECMAScript 提供了 3 个 基本包装类型 ：Boolean、Number 和 String。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS 内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据。</p>\n</li>\n</ul>\n<p>引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法;但基本类型不可以添加属性和方法。</p>\n<p>JavaScript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的 toString 方法来判断。</p>\n<p>JS 中的函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过 new 创建对象时就是构造函数，通过对象调用时就是方法。</p>\n<ul>\n<li>  JS 常用的内置对象有 window、Date、Array、JSON、RegExp 等，window 是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关的属性和状态，这个后面会讲到，Date 和 Array 使用场景最多，JSON 主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。</li>\n</ul>\n<h3 id=\"2、函数原型链\"><a href=\"#2、函数原型链\" class=\"headerlink\" title=\"2、函数原型链\"></a>2、函数原型链</h3><p>JS 是一种基于对象的语言，但在 ES6 之前是不支持继承的，为了具备继承的能力，JavaScript 在 函数对象上建立了原型对象 prototype，并以函数对象为主线，从上至下，在 JS 内部构建了一条 原型链 。原型链把一个个独立的对象联系在一起，Object 则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了 Object，并以 Object 终结。</p>\n<p>简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到 Object 对象为止，如果都没有找到该属性才会返回 undefined。因此，我们可以通过原型链来实现 JS 继承。</p>\n<h3 id=\"3、函数作用域\"><a href=\"#3、函数作用域\" class=\"headerlink\" title=\"3、函数作用域\"></a>3、函数作用域</h3><p>函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。因此， JS 中没有块级作用域，只有函数作用域，这种设计导致 JS 中出现了 变量提升 的问题。简单来说就是，将变量声明提升到它所在作用域的最开始的部分，为了解决变量提升带来的副作用，ES6 新增了 let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题。</p>\n<h3 id=\"4、this-指针\"><a href=\"#4、this-指针\" class=\"headerlink\" title=\"4、this 指针\"></a>4、this 指针</h3><p>this 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this 指向规则也不一样：对于普通函数，this 始终指向全局对象 window;对于构造函数，this 则指向新创建的对象;对于方法，this 指向调用该方法的对象。另外，Function 对象也提供了 call、apply 和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind 一般在事件回调中使用，而 call 和 apply 的区别只是参数的传递方式不同。</p>\n<p>如果往深的去理解，无论什么函数，this 是否被改变， 本质上，this 均指向触发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。</p>\n<h3 id=\"5、new-操作符\"><a href=\"#5、new-操作符\" class=\"headerlink\" title=\"5、new 操作符\"></a>5、new 操作符</h3><p>函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()。前面提到，JS 中的函数即可以是函数，也可以是方法，还可以是构造函数。当使用 new 来创建对象时，该函数就是构造函数，JS 将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型 prototype 中的方法和属性。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.cnblogs.com/onepixel/p/7021506.html\">https://www.cnblogs.com/onepixel/p/7021506.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p><strong>Web 前端技术由 html、css 和 javascript 三大部分构成，是一个庞大而复杂的技术体系，其复杂程度不低于任何一门后端语言。</strong> 本文从一个小项目入手，由浅至深，逐步介绍前端系统的一些基础知识，旨在帮助初学前端的小伙伴快速地形成一些基础概念。</p>\n<h2 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h2><ul>\n<li>  打开 shell，使用命令新建项目文件夹：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir html-css-js //新建项目文件夹，命名html-css-js</span><br><span class=\"line\">cd html-css-js //进入项目</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  使用 npm 初始化项目：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init //初始化项目，之后进行简单配置，回车跳过或使用默认值</span><br><span class=\"line\"></span><br><span class=\"line\">package name: html-css-js                   //项目名称</span><br><span class=\"line\">version:   (1.0.0)                          //版本号</span><br><span class=\"line\">description: a introduce to html-css-js     //项目描述</span><br><span class=\"line\">entry point: (index.js)                     //项目入口文件</span><br><span class=\"line\">test command:                               //执行命令</span><br><span class=\"line\">git repository:                             //git仓库地址</span><br><span class=\"line\">keywords：                                  //项目关键字</span><br><span class=\"line\">author: john                                //作者名字</span><br><span class=\"line\">license:                                    //发行项目证书</span><br></pre></td></tr></table></figure>\n\n<p>下面分别新建 html、css、js 三个文件，它们三者这件的关系可以用下图进行类比：<br><img src=\"/JohnChu.github.io/2022/04/01/An-introduction-to-HTML-CSS-JS/metaphor.png\" alt=\"01\"></p>\n<ul>\n<li>  使用编辑器打开该项目文件夹，然后新建一个 html 文件（命名 index.html），作为页面的骨架</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://www.w3schools.com/w3css/4/w3.css&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;hello&quot;</span>&gt;</span></span><br><span class=\"line\">            hello world!</span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;cue&quot;</span>&gt;</span>点我变大<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  新建 css 文件，用来控制 html 中的样式</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.hello</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: aquamarine;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  新建 js，实现一些页面操作和功能</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;.hello&quot;</span>);</span><br><span class=\"line\">hello.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">changeSize</span>(hello);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">changeSize</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> style = <span class=\"variable language_\">window</span>.<span class=\"title function_\">getComputedStyle</span>(obj, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cue = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;cue&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (style.<span class=\"property\">fontSize</span> === <span class=\"string\">&quot;50px&quot;</span>) &#123;</span><br><span class=\"line\">        obj.<span class=\"property\">style</span> = <span class=\"string\">&quot;font-size:100px&quot;</span>;</span><br><span class=\"line\">        cue.<span class=\"property\">innerHTML</span> = <span class=\"string\">&quot;点我变小&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.<span class=\"property\">style</span> = <span class=\"string\">&quot;font-size:50px&quot;</span>;</span><br><span class=\"line\">        cue.<span class=\"property\">innerHTML</span> = <span class=\"string\">&quot;点我变大&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们还需要一些额外的中间件将项目运行起来</strong><br>首先，安装 express 来启动服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i express --save</span><br></pre></td></tr></table></figure>\n\n<p>然后，新建 app.js 作为启动文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;express&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;path&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(express.<span class=\"title function_\">static</span>(path.<span class=\"title function_\">join</span>(__dirname, <span class=\"string\">&quot;&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> server = app.<span class=\"title function_\">listen</span>(<span class=\"number\">8081</span>, <span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> host = server.<span class=\"title function_\">address</span>().<span class=\"property\">address</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> port = server.<span class=\"title function_\">address</span>().<span class=\"property\">port</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;应用实例，访问地址为 http://%s:%s&quot;</span>, host, port);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其中最主要的部分是 app.use(express.static(path.join(__dirname, ‘’))) ，该行代码是在 express 添加中间件，设置静态资源路径为根目录，所有的 HTML、CSS、JS 等文件都放在<strong>根目录</strong>下即可</p>\n<p>最后，使用 node 运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node app.js //项目最终运行在127.0.0.1:8081</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML-知识点\"><a href=\"#HTML-知识点\" class=\"headerlink\" title=\"HTML 知识点\"></a>HTML 知识点</h2><h3 id=\"1、BOM\"><a href=\"#1、BOM\" class=\"headerlink\" title=\"1、BOM\"></a>1、BOM</h3><p>BOM 是 Browser Object Model 的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即 BOM。BOM 的核心对象就是 window，window 对象也是 BOM 的顶级对象，其中包含了浏览器的 6 个核心模块：</p>\n<ul>\n<li><p>  document -即文档对象，渲染引擎在解析 HTML 代码时，会为每一个元素生成对应的 DOM 对象，由于元素之间有层级关系，因此整个 HTML 代码解析完以后，会生成一个由不同节点组成的树形结构，俗称 DOM 树，document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。</p>\n</li>\n<li><p>  frames - HTML 子框架，即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。</p>\n</li>\n<li><p>  history - 以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。</p>\n</li>\n<li><p>  location - 提供了当前窗口中加载的文档相关信息以及一些导航功能。</p>\n</li>\n<li><p>  navigator - 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。</p>\n</li>\n<li><p>  screen - 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。</p>\n</li>\n</ul>\n<h3 id=\"2、DOM-系统\"><a href=\"#2、DOM-系统\" class=\"headerlink\" title=\"2、DOM 系统\"></a>2、DOM 系统</h3><p>DOM 是 Document Object Model 的缩写，即 文档对象模型，是所有浏览器公共遵守的标准，DOM 将 HTML 和 XML 文档映射成一个由不同节点组成的树型结构，俗称 DOM 树。其核心对象是 document，用于描述 DOM 树的状态和属性，并提供对应的 DOM 操作 API。随着历史的发展，DOM 被划分为 1 级、2 级、3 级，共 3 个级别：</p>\n<ul>\n<li><p>  1 级 DOM - 在 1998 年 10 月份成为 W3C 的提议，由 DOM 核心与 DOM HTML 两个模块组成。DOM 核心能映射以 XML 为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML 通过添加 HTML 专用的对象与函数对 DOM 核心进行了扩展。</p>\n</li>\n<li><p>  2 级 DOM - 鉴于 1 级 DOM 仅以映射文档结构为目标，DOM 2 级面向更为宽广。通过对原有 DOM 的扩展，2 级 DOM 通过对象接口增加了对鼠标和用户界面事件(DHTML 长期支持鼠标与用户界面事件)、范围、遍历(重复执行 DOM 文档)和层叠样式表(CSS)的支持。同时也对 DOM 1 的核心进行了扩展，从而可支持 XML 命名空间。</p>\n</li>\n<li><p>  3 级 DOM -通过引入统一方式载入和保存文档和文档验证方法对 DOM 进行进一步扩展，DOM3 包含一个名为“DOM 载入与保存”的新模块，DOM 核心扩展后可支持 XML1.0 的所有内容，包括 XMLInfoset、 XPath、和 XML Base。</p>\n</li>\n</ul>\n<p><img src=\"/JohnChu.github.io/2022/04/01/An-introduction-to-HTML-CSS-JS/DOM.png\" alt=\"02\"></p>\n<p>从图中可以看出，移动端常用的 webkit 内核浏览器目前只支持 DOM2，而不支持 DOM3 。</p>\n<h3 id=\"3、事件系统\"><a href=\"#3、事件系统\" class=\"headerlink\" title=\"3、事件系统\"></a>3、事件系统</h3><p>事件是用户与页面交互的基础，到目前为止，DOM 事件从 PC 端的 鼠标事件(mouse) 发展到了 移动端的 触摸事件(touch) 和手势事件(guesture)，touch 事件描述了手指在屏幕操作的每一个细节，guesture 则是描述多手指操作时更为复杂的情况。</p>\n<p>DOM2.0 模型将事件处理流程分为三个阶段，即 事件捕获阶段 、 事件处理阶段 、 事件冒泡阶段， 如图所示：</p>\n<ul>\n<li><p>  事件捕获 ：当用户触发点击事件后，顶层对象 document 就会发出一个事件流，从最外层的 DOM 节点向目标元素节点传递，最终到达目标元素。</p>\n</li>\n<li><p>  事件处理 ：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。</p>\n</li>\n<li><p>  事件冒泡 ：事件流从目标元素开始，向最外层 DOM 节点传递，途中如果有节点绑定了事件处理函数，这些函数就会被执行。</p>\n</li>\n</ul>\n<p>利用事件冒泡原理可以实现 事件委托，所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素再通过 event.target 获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。</p>\n<h3 id=\"4、HTML-解析过程\"><a href=\"#4、HTML-解析过程\" class=\"headerlink\" title=\"4、HTML 解析过程\"></a>4、HTML 解析过程</h3><p>渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程：<br><img src=\"/JohnChu.github.io/2022/04/01/An-introduction-to-HTML-CSS-JS/render.png\" alt=\"03\"></p>\n<ul>\n<li>  HTML Parser 解析 HTML 文档，并将各标记逐个转化为 DOM 节点，生成 <strong>DOM 树</strong>。</li>\n<li>  CSS Parser 解析外部 CSS 文件以及样式元素中的样式数据，生成 <strong>CSSOM 树</strong>。</li>\n<li>  <strong>DOM 树</strong> 和 <strong>CSSOM 树</strong> 通过 “附着” 将创建另一个树结构：<strong>渲染树</strong>。</li>\n<li>  <strong>渲染树</strong> 包含多个带有视觉属性（如颜色和尺寸）的矩形，这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</li>\n<li>  渲染树构建完毕之后，进入 <strong>布局</strong> 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。</li>\n<li>  下一个阶段是 <strong>绘制</strong>，渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。</li>\n</ul>\n<p>需要注意的是：</p>\n<blockquote>\n<p>这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n</blockquote>\n<h2 id=\"CSS-知识点\"><a href=\"#CSS-知识点\" class=\"headerlink\" title=\"CSS 知识点\"></a>CSS 知识点</h2><h3 id=\"1、CSS-选择器\"><a href=\"#1、CSS-选择器\" class=\"headerlink\" title=\"1、CSS 选择器\"></a>1、CSS 选择器</h3><p>CSS 选择器即通过某种规则来匹配相应的标签，并为其设置 CSS 样式，常用的有：</p>\n<ul>\n<li>  类选择器(.a)</li>\n<li>  标签选择器(div)</li>\n<li>  ID 选择器(#a)</li>\n<li>  后代选择器(h1 .a)</li>\n<li>  子元素选择器(h1 &gt; a)</li>\n<li>  群组选择器(h1,h2,h3)</li>\n<li>  伪类选择器(::before/::after)</li>\n<li>  相邻兄弟选择器(h1 + p)</li>\n<li>  属性选择器(a[href][title])</li>\n</ul>\n<h3 id=\"2、CSS-Reset\"><a href=\"#2、CSS-Reset\" class=\"headerlink\" title=\"2、CSS Reset\"></a>2、CSS Reset</h3><p>HTML 标签在不设置任何样式的情况下，也会有一个默认的 CSS 样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是 CSSReset ，即 CSS 样式重置，比如：*{margin:0,padding:0} 就是最简单 CSS Reset。</p>\n<h3 id=\"3、盒子布局\"><a href=\"#3、盒子布局\" class=\"headerlink\" title=\"3、盒子布局\"></a>3、盒子布局</h3><p>盒子模型是 CSS 比较重要的一个概念，也是 CSS 布局的基石。</p>\n<p>常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding 和 content 等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing 属性的设置会影响盒子 width 和 height 的计算。</p>\n<h3 id=\"4、浮动布局\"><a href=\"#4、浮动布局\" class=\"headerlink\" title=\"4、浮动布局\"></a>4、浮动布局</h3><p>设置元素的 float 属性值为 left 或 right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear:both，更高级一点的就给父容器设置 before/after 来模拟一个空元素，还可以直接设置 overflow 属性为 auto/hidden 来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block)和 table 也可以实现同样的效果。</p>\n<h3 id=\"5、定位布局\"><a href=\"#5、定位布局\" class=\"headerlink\" title=\"5、定位布局\"></a>5、定位布局</h3><p>设置元素的 position 属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，releave 是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用;absolute 是绝对定位，它以离自己最近的定位父容器作为参照进行偏移;为了对某个元素进行定位，常用的方式就是设置父容器的 poistion:relative，因为相对定位元素在不设置 top 和 left 值时，不会对元素位置产生影响;fixed 即固定定位，它则以浏览器窗口为参照物，PC 网页底部悬停的 banner 一般都可以通过 fixed 定位来实现，但 fixed 属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。</p>\n<h3 id=\"6、弹性布局\"><a href=\"#6、弹性布局\" class=\"headerlink\" title=\"6、弹性布局\"></a>6、弹性布局</h3><p>弹性布局即 Flex 布局，定义了 flex 的容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小;然后当 Flex 容器被应用一个大小时(width 和 height)，将会自动调整容器中的元素适应新大小。Flex 容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向(横向和纵向)和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>\n<h2 id=\"JS-知识点\"><a href=\"#JS-知识点\" class=\"headerlink\" title=\"JS 知识点\"></a>JS 知识点</h2><h3 id=\"1、基础语法\"><a href=\"#1、基础语法\" class=\"headerlink\" title=\"1、基础语法\"></a>1、基础语法</h3><p>JavaScript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。</p>\n<ul>\n<li><p>  在 ES5 中，变量声明有两种方式，分别是 var 和 function ，var 用于声明普通的变量，接收任意类型，function 用于声明函数。另外，ES6 新增了 let、const、import 和 class 等四个命令，分别用以声明 普通变量、静态变量、模块 和 类 。</p>\n</li>\n<li><p>  JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了 Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(Primitive Type)。</p>\n</li>\n<li><p>  原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中(按值访问)。为了便于操作这类数据，ECMAScript 提供了 3 个 基本包装类型 ：Boolean、Number 和 String。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS 内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据。</p>\n</li>\n</ul>\n<p>引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法;但基本类型不可以添加属性和方法。</p>\n<p>JavaScript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的 toString 方法来判断。</p>\n<p>JS 中的函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过 new 创建对象时就是构造函数，通过对象调用时就是方法。</p>\n<ul>\n<li>  JS 常用的内置对象有 window、Date、Array、JSON、RegExp 等，window 是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关的属性和状态，这个后面会讲到，Date 和 Array 使用场景最多，JSON 主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。</li>\n</ul>\n<h3 id=\"2、函数原型链\"><a href=\"#2、函数原型链\" class=\"headerlink\" title=\"2、函数原型链\"></a>2、函数原型链</h3><p>JS 是一种基于对象的语言，但在 ES6 之前是不支持继承的，为了具备继承的能力，JavaScript 在 函数对象上建立了原型对象 prototype，并以函数对象为主线，从上至下，在 JS 内部构建了一条 原型链 。原型链把一个个独立的对象联系在一起，Object 则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了 Object，并以 Object 终结。</p>\n<p>简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到 Object 对象为止，如果都没有找到该属性才会返回 undefined。因此，我们可以通过原型链来实现 JS 继承。</p>\n<h3 id=\"3、函数作用域\"><a href=\"#3、函数作用域\" class=\"headerlink\" title=\"3、函数作用域\"></a>3、函数作用域</h3><p>函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。因此， JS 中没有块级作用域，只有函数作用域，这种设计导致 JS 中出现了 变量提升 的问题。简单来说就是，将变量声明提升到它所在作用域的最开始的部分，为了解决变量提升带来的副作用，ES6 新增了 let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题。</p>\n<h3 id=\"4、this-指针\"><a href=\"#4、this-指针\" class=\"headerlink\" title=\"4、this 指针\"></a>4、this 指针</h3><p>this 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this 指向规则也不一样：对于普通函数，this 始终指向全局对象 window;对于构造函数，this 则指向新创建的对象;对于方法，this 指向调用该方法的对象。另外，Function 对象也提供了 call、apply 和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind 一般在事件回调中使用，而 call 和 apply 的区别只是参数的传递方式不同。</p>\n<p>如果往深的去理解，无论什么函数，this 是否被改变， 本质上，this 均指向触发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。</p>\n<h3 id=\"5、new-操作符\"><a href=\"#5、new-操作符\" class=\"headerlink\" title=\"5、new 操作符\"></a>5、new 操作符</h3><p>函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()。前面提到，JS 中的函数即可以是函数，也可以是方法，还可以是构造函数。当使用 new 来创建对象时，该函数就是构造函数，JS 将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型 prototype 中的方法和属性。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.cnblogs.com/onepixel/p/7021506.html\">https://www.cnblogs.com/onepixel/p/7021506.html</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/electron02-调用DLL/01.png","post":"cl1g7jc1l000188tc9w87bc3f","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/electron02-调用DLL/02.png","post":"cl1g7jc1l000188tc9w87bc3f","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/electron02-调用DLL/03.png","post":"cl1g7jc1l000188tc9w87bc3f","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/electron02-调用DLL/04.png","post":"cl1g7jc1l000188tc9w87bc3f","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/electron02-调用DLL/05.png","post":"cl1g7jc1l000188tc9w87bc3f","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/部署项目到服务器操作流程/01.png","post":"cl1g7jc1p000388tc0o55h57l","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/部署项目到服务器操作流程/02.png","post":"cl1g7jc1p000388tc0o55h57l","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/An-introduction-to-HTML-CSS-JS/DOM.png","post":"cl1g7jc1q000488tc13yj322e","slug":"DOM.png","modified":1,"renderable":1},{"_id":"source/_posts/An-introduction-to-HTML-CSS-JS/metaphor.png","post":"cl1g7jc1q000488tc13yj322e","slug":"metaphor.png","modified":1,"renderable":1},{"_id":"source/_posts/An-introduction-to-HTML-CSS-JS/render.png","post":"cl1g7jc1q000488tc13yj322e","slug":"render.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}